{
  "master": {
    "tasks": [
      {
        "id": 27,
        "title": "Create URL Detection Utility Function",
        "description": "Implement a reusable utility function that detects URLs in text and converts them to clickable links",
        "details": "Create a new file `lib/utils.ts` with a `linkifyText()` function that:\n\n1. Takes a string input and returns JSX\n2. Uses regex to identify URLs with http/https protocols\n3. Splits text into segments (regular text and URLs)\n4. Returns JSX with URLs wrapped in `<a>` tags with appropriate attributes\n5. Ensures links open in new tabs with `target=\"_blank\"` and `rel=\"noopener noreferrer\"`\n\nExample implementation:\n```typescript\nimport React from 'react';\n\nexport function linkifyText(text: string): React.ReactNode {\n  if (!text) return '';\n  \n  // Basic URL regex for http/https protocols\n  const urlRegex = /(https?:\\/\\/[^\\s]+)/g;\n  \n  // Split text by URLs\n  const parts = text.split(urlRegex);\n  \n  // Find all URLs in the text\n  const urls = text.match(urlRegex) || [];\n  \n  // Combine parts and URLs into a single array of React nodes\n  const result: React.ReactNode[] = [];\n  \n  parts.forEach((part, i) => {\n    // Add the text part\n    if (part) result.push(part);\n    \n    // Add the URL part (if there is one)\n    if (urls[i]) {\n      result.push(\n        <a \n          key={i} \n          href={urls[i]} \n          target=\"_blank\" \n          rel=\"noopener noreferrer\"\n          className=\"text-blue-600 hover:underline\"\n        >\n          {urls[i]}\n        </a>\n      );\n    }\n  });\n  \n  return result;\n}\n```",
        "testStrategy": "Create unit tests using Jest and React Testing Library to:\n1. Verify the function correctly identifies URLs with http/https protocols\n2. Test that non-URL text remains unchanged\n3. Confirm the function returns proper JSX with anchor tags\n4. Validate that anchor tags have correct attributes (href, target, rel)\n5. Test edge cases like empty strings, strings with only URLs, and strings with multiple URLs",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Enhance URL Detection Patterns",
        "description": "Extend the URL detection regex to support additional URL formats including www. patterns and localhost URLs",
        "details": "Modify the `linkifyText()` function in `lib/utils.ts` to enhance URL detection:\n\n1. Update the regex pattern to support three URL formats:\n   - URLs with http/https protocols\n   - URLs starting with www. (without protocol)\n   - localhost URLs with port numbers\n\n2. Ensure proper URL handling for each pattern:\n   - For www. patterns without protocol, prepend 'http://' to the href attribute\n   - For localhost URLs, ensure they work correctly with port numbers\n\nExample enhanced regex implementation:\n```typescript\n// Enhanced URL regex for multiple patterns\nconst urlRegex = /(https?:\\/\\/[^\\s]+)|(www\\.[^\\s]+)|(localhost:[0-9]+[^\\s]*)/g;\n\n// Function to normalize URL for href attribute\nconst normalizeUrl = (url: string): string => {\n  if (url.startsWith('www.')) {\n    return `http://${url}`;\n  }\n  if (url.startsWith('localhost')) {\n    return `http://${url}`;\n  }\n  return url;\n};\n\n// Update the anchor creation to use normalized URLs\n<a \n  key={i} \n  href={normalizeUrl(urls[i])} \n  target=\"_blank\" \n  rel=\"noopener noreferrer\"\n  className=\"text-blue-600 hover:underline\"\n>\n  {urls[i]}\n</a>\n```",
        "testStrategy": "Extend the existing unit tests to:\n1. Verify detection of www. patterns without protocols\n2. Test localhost URL detection with various port numbers\n3. Confirm proper URL normalization for href attributes\n4. Test mixed content with multiple URL formats\n5. Validate edge cases like malformed URLs and unusual patterns",
        "priority": "medium",
        "dependencies": [27],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Update Card Description Component",
        "description": "Integrate the URL detection utility with the card description component to render clickable links",
        "details": "Modify the `CardItem.tsx` component to use the linkifyText utility:\n\n1. Import the linkifyText function:\n```typescript\nimport { linkifyText } from '../lib/utils';\n```\n\n2. Update the card description rendering to use the linkifyText function:\n```typescript\n// Before:\n<p className=\"text-gray-700 mt-2\">{card.description}</p>\n\n// After:\n<p className=\"text-gray-700 mt-2\">{linkifyText(card.description)}</p>\n```\n\n3. Ensure the component correctly handles empty descriptions\n\n4. Verify that the styling of links integrates well with the existing card styling\n\n5. Test that links are clickable and open in new tabs\n\n6. Confirm that the plain text storage format is maintained when saving card descriptions",
        "testStrategy": "Create component tests using React Testing Library to:\n1. Verify links are correctly rendered in card descriptions\n2. Test that clicking links opens them in new tabs\n3. Confirm that non-URL text renders normally\n4. Test with various description content including multiple links\n5. Verify that editing and saving descriptions maintains the plain text format",
        "priority": "high",
        "dependencies": [27],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Update Comment Component",
        "description": "Integrate the URL detection utility with the comment component to render clickable links in comment content",
        "details": "Modify the `CommentItem.tsx` component to use the linkifyText utility:\n\n1. Import the linkifyText function:\n```typescript\nimport { linkifyText } from '../lib/utils';\n```\n\n2. Update the comment content rendering to use the linkifyText function:\n```typescript\n// Before:\n<p className=\"text-gray-600\">{comment.content}</p>\n\n// After:\n<p className=\"text-gray-600\">{linkifyText(comment.content)}</p>\n```\n\n3. Ensure the component correctly handles empty comments\n\n4. Verify that the styling of links integrates well with the existing comment styling\n\n5. Test that links are clickable and open in new tabs\n\n6. Confirm that the plain text storage format is maintained when saving comments",
        "testStrategy": "Create component tests using React Testing Library to:\n1. Verify links are correctly rendered in comments\n2. Test that clicking links opens them in new tabs\n3. Confirm that non-URL text renders normally\n4. Test with various comment content including multiple links\n5. Verify that adding new comments with URLs works correctly\n6. Test that the plain text format is maintained in the database",
        "priority": "high",
        "dependencies": [27],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Add Link Styling with Tailwind CSS",
        "description": "Implement consistent styling for links across the application using Tailwind CSS",
        "details": "Create and apply consistent link styling using Tailwind CSS:\n\n1. Define a standard link style in the linkifyText function:\n```typescript\n<a \n  key={i} \n  href={normalizeUrl(urls[i])} \n  target=\"_blank\" \n  rel=\"noopener noreferrer\"\n  className=\"text-blue-600 hover:underline transition-colors duration-200\"\n>\n  {urls[i]}\n</a>\n```\n\n2. Consider adding visual indicators for different link types (optional):\n```typescript\n// Function to determine link type and return appropriate classes\nconst getLinkClasses = (url: string): string => {\n  if (url.includes('github.com')) {\n    return 'text-purple-600 hover:underline';\n  }\n  if (url.startsWith('localhost')) {\n    return 'text-green-600 hover:underline';\n  }\n  return 'text-blue-600 hover:underline';\n};\n\n// Use in anchor tag\nclassName={getLinkClasses(urls[i])}\n```\n\n3. Ensure link styles are consistent with the application's design system\n\n4. Test the styling across different components and contexts\n\n5. Verify that link styles are accessible and meet contrast requirements",
        "testStrategy": "1. Manually test link styling across different components\n2. Verify that hover states work correctly\n3. Test link appearance in different contexts (card descriptions, comments)\n4. Check that link styling meets accessibility standards for color contrast\n5. Verify that any visual indicators for different link types work correctly\n6. Test on different browsers to ensure consistent appearance",
        "priority": "medium",
        "dependencies": [27, 29, 30],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Verify Export Functionality Compatibility",
        "description": "Ensure that the URL linking feature doesn't break the existing export functionality",
        "details": "Test and verify that the export functionality works correctly with the new URL linking feature:\n\n1. Review the current export implementation to understand how card descriptions and comments are processed\n\n2. Verify that the linkifyText function is only used for rendering and doesn't affect the stored text format\n\n3. Create test cases with various URL patterns in card descriptions and comments\n\n4. Test the export functionality with these test cases\n\n5. Verify that exported data contains the original plain text with URLs (not HTML)\n\n6. If any issues are found, modify the export function to ensure it uses the raw text data rather than the rendered HTML\n\nExample verification approach:\n```typescript\n// Ensure export function uses raw text data\nexport function exportBoard(board) {\n  return {\n    ...board,\n    cards: board.cards.map(card => ({\n      ...card,\n      // Use the raw description, not the rendered HTML\n      description: card.description,\n      comments: card.comments.map(comment => ({\n        ...comment,\n        // Use the raw content, not the rendered HTML\n        content: comment.content\n      }))\n    }))\n  };\n}\n```",
        "testStrategy": "1. Create integration tests that verify export functionality with URLs in content\n2. Test exporting boards with various URL patterns in descriptions and comments\n3. Verify that exported data contains the original plain text URLs\n4. Test importing exported data to ensure round-trip integrity\n5. Manually test the export feature with real-world examples\n6. Verify that exported data can be correctly imported into other systems if applicable",
        "priority": "high",
        "dependencies": [29, 30],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Create Comprehensive Test Suite",
        "description": "Develop a comprehensive test suite for the URL linking feature to ensure reliability and correctness",
        "details": "Create a comprehensive test suite covering all aspects of the URL linking feature:\n\n1. Unit tests for the linkifyText utility function:\n```typescript\ndescribe('linkifyText', () => {\n  it('should return empty string for empty input', () => {\n    const result = linkifyText('');\n    expect(result).toEqual('');\n  });\n\n  it('should return plain text for input without URLs', () => {\n    const text = 'This is plain text without URLs';\n    const result = linkifyText(text);\n    expect(result).toEqual([text]);\n  });\n\n  it('should convert http URLs to clickable links', () => {\n    const text = 'Check this link: http://example.com';\n    const result = linkifyText(text);\n    expect(result).toHaveLength(2);\n    expect(result[0]).toEqual('Check this link: ');\n    expect(result[1].props.href).toEqual('http://example.com');\n  });\n\n  // Additional tests for other URL patterns\n});\n```\n\n2. Component tests for CardItem and CommentItem:\n```typescript\ndescribe('CardItem with URL linking', () => {\n  it('should render clickable links in description', () => {\n    const card = {\n      id: '1',\n      title: 'Test Card',\n      description: 'Visit http://example.com for more info'\n    };\n    \n    const { getByText } = render(<CardItem card={card} />);\n    const link = getByText('http://example.com');\n    \n    expect(link.tagName).toBe('A');\n    expect(link.href).toBe('http://example.com/');\n    expect(link.target).toBe('_blank');\n  });\n});\n```\n\n3. Integration tests for the complete feature:\n```typescript\ndescribe('URL linking integration', () => {\n  it('should maintain plain text in storage while rendering clickable links', async () => {\n    // Setup test data\n    // Render components\n    // Verify links are clickable\n    // Update content with new URLs\n    // Verify storage format remains plain text\n    // Verify export functionality works correctly\n  });\n});\n```\n\n4. Create a manual testing checklist for real-world scenarios",
        "testStrategy": "1. Run the complete test suite using Jest and React Testing Library\n2. Verify all tests pass consistently\n3. Measure test coverage and ensure it meets project standards\n4. Perform manual testing using the created checklist\n5. Test with real-world URL examples from development workflow\n6. Verify browser compatibility across modern browsers\n7. Document any edge cases or limitations discovered during testing",
        "priority": "medium",
        "dependencies": [27, 28, 29, 30, 31, 32],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Document URL Linking Feature",
        "description": "Create documentation for the URL linking feature including implementation details and usage guidelines",
        "details": "Create comprehensive documentation for the URL linking feature:\n\n1. Update the project README.md with information about the new feature:\n```markdown\n## URL Linking\n\nDriftBoard now supports automatic URL detection and linking in card descriptions and comments. URLs are automatically converted to clickable links that open in new tabs.\n\nSupported URL formats:\n- Standard http/https URLs (e.g., https://example.com)\n- URLs starting with www (e.g., www.example.com)\n- Localhost URLs with port numbers (e.g., localhost:3000)\n\nThis feature makes it easier to reference external resources, documentation, and related items without breaking your workflow.\n```\n\n2. Add code documentation for the linkifyText utility function:\n```typescript\n/**\n * Converts URLs in text to clickable links\n * \n * @param text - The input text that may contain URLs\n * @returns React nodes with URLs converted to anchor tags\n * \n * Supported URL formats:\n * - http/https protocols (e.g., https://example.com)\n * - www patterns without protocol (e.g., www.example.com)\n * - localhost URLs with port numbers (e.g., localhost:3000)\n */\nexport function linkifyText(text: string): React.ReactNode {\n  // Implementation\n}\n```\n\n3. Create developer documentation explaining:\n   - How the feature works\n   - How to use it in new components\n   - Testing considerations\n   - Known limitations\n\n4. Update any user-facing documentation to explain the new feature",
        "testStrategy": "1. Review documentation for accuracy and completeness\n2. Verify code examples in documentation work correctly\n3. Have another team member review the documentation\n4. Test following the documentation to implement the feature in a new component\n5. Verify user-facing documentation clearly explains the feature",
        "priority": "low",
        "dependencies": [27, 28, 29, 30, 31, 32, 33],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Update Card Data Model with Status Field",
        "description": "Modify the existing card data model to include a unified status field that can track the lifecycle state of a card.",
        "details": "Update the card schema to include a 'status' field with possible values: 'active', 'done', 'archived', 'deleted'. Ensure all existing cards default to 'active' status. This is a critical foundation for the new views functionality. Avoid using separate boolean flags as specified in the PRD. Update any relevant TypeScript interfaces or database schemas accordingly. Example implementation:\n```typescript\ninterface Card {\n  id: string;\n  title: string;\n  content: string;\n  // other existing fields\n  status: 'active' | 'done' | 'archived' | 'deleted';\n}\n\n// Migration function for existing cards\nconst migrateExistingCards = async () => {\n  const cardRefs = await db.collection('cards').get();\n  const batch = db.batch();\n  \n  cardRefs.docs.forEach(doc => {\n    if (!doc.data().status) {\n      batch.update(doc.ref, { status: 'active' });\n    }\n  });\n  \n  return batch.commit();\n};\n```",
        "testStrategy": "1. Unit test the card model to ensure it correctly validates the status field.\n2. Write a test to verify the migration function correctly updates existing cards.\n3. Test edge cases where a card might have an invalid status value.\n4. Verify that the database schema correctly stores and retrieves the status field.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implement Status Change API Endpoints",
        "description": "Create or update API endpoints to handle changing a card's status between active, done, archived, and deleted states.",
        "details": "Implement RESTful endpoints or GraphQL mutations that allow changing a card's status. Ensure proper validation and error handling. The endpoints should handle the transition between any two states (e.g., active to done, deleted to active for restoration). Example implementation:\n```typescript\n// REST endpoint example\napp.put('/api/cards/:id/status', authenticate, async (req, res) => {\n  const { id } = req.params;\n  const { status } = req.body;\n  \n  if (!['active', 'done', 'archived', 'deleted'].includes(status)) {\n    return res.status(400).json({ error: 'Invalid status value' });\n  }\n  \n  try {\n    await db.collection('cards').doc(id).update({ status });\n    return res.status(200).json({ success: true });\n  } catch (error) {\n    console.error('Error updating card status:', error);\n    return res.status(500).json({ error: 'Failed to update card status' });\n  }\n});\n```",
        "testStrategy": "1. Unit test the API endpoints with valid and invalid status values.\n2. Integration test to verify the database is correctly updated when the endpoint is called.\n3. Test error handling for cases like non-existent cards or unauthorized access.\n4. Performance test to ensure the endpoint can handle multiple simultaneous status changes.",
        "priority": "high",
        "dependencies": [35],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Create Kebab Menu in Board Header",
        "description": "Add a kebab menu (three-dot icon) to the board's header area that will contain options to view Done, Archived, and Deleted cards.",
        "details": "Implement a dropdown menu triggered by a kebab icon (three vertical dots) in the board header. The menu should contain three options: 'View Done', 'View Archived', and 'View Deleted'. Use appropriate styling to match the existing UI. Example implementation:\n```jsx\nconst BoardHeader = () => {\n  const [menuOpen, setMenuOpen] = useState(false);\n  \n  const handleViewStatusItems = (status) => {\n    // Will be implemented in another task\n    console.log(`View ${status} items`);\n    setMenuOpen(false);\n  };\n  \n  return (\n    <div className=\"board-header\">\n      {/* Existing header content */}\n      \n      <div className=\"kebab-menu-container\">\n        <button \n          className=\"kebab-button\" \n          onClick={() => setMenuOpen(!menuOpen)}\n          aria-label=\"More options\"\n        >\n          <svg>...</svg> {/* Three dots icon */}\n        </button>\n        \n        {menuOpen && (\n          <div className=\"kebab-menu\">\n            <button onClick={() => handleViewStatusItems('done')}>View Done</button>\n            <button onClick={() => handleViewStatusItems('archived')}>View Archived</button>\n            <button onClick={() => handleViewStatusItems('deleted')}>View Deleted</button>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Unit test the component to ensure it renders correctly.\n2. Test that clicking the kebab icon opens the menu and displays the three options.\n3. Test that clicking outside the menu closes it.\n4. Verify that clicking each option triggers the correct handler function.\n5. Test accessibility features like keyboard navigation and screen reader compatibility.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Implement Firestore Queries for Status-Based Views",
        "description": "Create optimized Firestore queries to fetch cards based on their status (done, archived, deleted) for the respective views.",
        "details": "Implement efficient Firestore queries that filter cards by their status field. Consider adding appropriate indexes to optimize query performance. These queries will be used to populate the modal views. Example implementation:\n```typescript\n// Query functions for different status views\nconst fetchCardsByStatus = async (status, boardId) => {\n  try {\n    const cardsRef = db.collection('cards');\n    const query = cardsRef\n      .where('boardId', '==', boardId)\n      .where('status', '==', status)\n      .orderBy('updatedAt', 'desc'); // Most recently updated first\n    \n    const snapshot = await query.get();\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error(`Error fetching ${status} cards:`, error);\n    throw error;\n  }\n};\n\n// Example usage\nexport const fetchDoneCards = (boardId) => fetchCardsByStatus('done', boardId);\nexport const fetchArchivedCards = (boardId) => fetchCardsByStatus('archived', boardId);\nexport const fetchDeletedCards = (boardId) => fetchCardsByStatus('deleted', boardId);\n```",
        "testStrategy": "1. Unit test each query function with mock Firestore data.\n2. Test performance with varying numbers of cards to ensure queries remain efficient.\n3. Verify that the queries correctly filter by both board ID and status.\n4. Test error handling for database connection issues.\n5. Verify that the returned data structure matches what the UI components expect.",
        "priority": "high",
        "dependencies": [35],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Design and Implement Modal View Component",
        "description": "Create a reusable floating modal component that will display cards with a specific status (Done, Archived, or Deleted).",
        "details": "Implement a modal component that can be triggered from the kebab menu. The modal should display a list of cards with the selected status, allow viewing card details, and provide options to restore cards. The modal should be dismissible and follow accessibility best practices. Example implementation:\n```jsx\nconst StatusModal = ({ status, isOpen, onClose }) => {\n  const [cards, setCards] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    if (!isOpen) return;\n    \n    const fetchCards = async () => {\n      setLoading(true);\n      try {\n        // Use the appropriate fetch function based on status\n        const fetchFunction = {\n          'done': fetchDoneCards,\n          'archived': fetchArchivedCards,\n          'deleted': fetchDeletedCards\n        }[status];\n        \n        const boardId = getCurrentBoardId(); // Implement this function\n        const fetchedCards = await fetchFunction(boardId);\n        setCards(fetchedCards);\n        setError(null);\n      } catch (err) {\n        setError('Failed to load cards');\n        console.error(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchCards();\n  }, [isOpen, status]);\n  \n  return (\n    <div className={`modal ${isOpen ? 'open' : ''}`}>\n      <div className=\"modal-content\">\n        <div className=\"modal-header\">\n          <h2>{status.charAt(0).toUpperCase() + status.slice(1)} Items</h2>\n          <button onClick={onClose} aria-label=\"Close modal\">×</button>\n        </div>\n        \n        <div className=\"modal-body\">\n          {loading && <p>Loading...</p>}\n          {error && <p className=\"error\">{error}</p>}\n          {!loading && !error && cards.length === 0 && (\n            <p>No {status} items found.</p>\n          )}\n          \n          <ul className=\"card-list\">\n            {cards.map(card => (\n              <li key={card.id} className=\"card-item\">\n                <div className=\"card-title\">{card.title}</div>\n                <button onClick={() => viewCardDetails(card)}>View</button>\n                <button onClick={() => restoreCard(card)}>Restore</button>\n              </li>\n            ))}\n          </ul>\n        </div>\n      </div>\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Unit test the modal component rendering with different statuses.\n2. Test loading states, error states, and empty states.\n3. Verify that the modal correctly fetches and displays cards based on status.\n4. Test that the modal can be opened and closed properly.\n5. Test accessibility features including keyboard navigation, focus trapping, and screen reader compatibility.\n6. Verify that the View and Restore buttons trigger the correct functions.",
        "priority": "medium",
        "dependencies": [37, 38],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Implement Card Detail View in Modal",
        "description": "Create functionality to view the full details of a card when selected from the status-based modal views.",
        "details": "Implement a detailed view of a card that appears when a user selects a card from the Done, Archived, or Deleted views. This should display all relevant card information in a readable format. Example implementation:\n```jsx\nconst CardDetailView = ({ card, onClose, onRestore }) => {\n  if (!card) return null;\n  \n  return (\n    <div className=\"card-detail-container\">\n      <div className=\"card-detail-header\">\n        <h3>{card.title}</h3>\n        <button onClick={onClose} aria-label=\"Close detail view\">×</button>\n      </div>\n      \n      <div className=\"card-detail-content\">\n        <p>{card.content}</p>\n        \n        {/* Display other card properties like dates, tags, etc. */}\n        {card.createdAt && (\n          <div className=\"card-meta\">\n            <span>Created: {new Date(card.createdAt).toLocaleString()}</span>\n          </div>\n        )}\n        \n        {card.tags && card.tags.length > 0 && (\n          <div className=\"card-tags\">\n            {card.tags.map(tag => (\n              <span key={tag} className=\"tag\">{tag}</span>\n            ))}\n          </div>\n        )}\n      </div>\n      \n      <div className=\"card-detail-actions\">\n        <button \n          className=\"restore-button\" \n          onClick={() => onRestore(card)}\n        >\n          Restore to Board\n        </button>\n      </div>\n    </div>\n  );\n};\n\n// Usage within the StatusModal component\nconst StatusModal = ({ /* ... */ }) => {\n  const [selectedCard, setSelectedCard] = useState(null);\n  \n  const viewCardDetails = (card) => {\n    setSelectedCard(card);\n  };\n  \n  const closeCardDetails = () => {\n    setSelectedCard(null);\n  };\n  \n  // ... existing code\n  \n  return (\n    <div className=\"modal\">\n      {/* ... existing modal code */}\n      \n      {selectedCard && (\n        <CardDetailView \n          card={selectedCard} \n          onClose={closeCardDetails} \n          onRestore={restoreCard}\n        />\n      )}\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Unit test the CardDetailView component with various card data structures.\n2. Test that all card properties are correctly displayed.\n3. Verify that the close button properly dismisses the detail view.\n4. Test that the restore button triggers the correct function with the card data.\n5. Test accessibility features for the detail view.\n6. Verify that the component handles edge cases like missing or malformed card data.",
        "priority": "medium",
        "dependencies": [39],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Implement Card Restoration Functionality",
        "description": "Create the functionality to restore cards from Done, Archived, or Deleted status back to active status on the board.",
        "details": "Implement the logic to restore a card from any non-active status back to active status. When restored, the card should be placed at the top of its original list as specified in the PRD. Example implementation:\n```typescript\nconst restoreCard = async (card) => {\n  try {\n    // Update the card status to active\n    await db.collection('cards').doc(card.id).update({\n      status: 'active',\n      updatedAt: firebase.firestore.FieldValue.serverTimestamp()\n    });\n    \n    // Get the original list to place the card at the top\n    const listRef = db.collection('lists').doc(card.listId);\n    const listDoc = await listRef.get();\n    \n    if (listDoc.exists) {\n      // Get current cards in the list\n      const list = listDoc.data();\n      const cardIds = list.cardIds || [];\n      \n      // Add the restored card to the top of the list if not already present\n      if (!cardIds.includes(card.id)) {\n        const updatedCardIds = [card.id, ...cardIds];\n        await listRef.update({ cardIds: updatedCardIds });\n      }\n      \n      return true;\n    } else {\n      // If original list doesn't exist, add to the first available list\n      const listsSnapshot = await db.collection('lists')\n        .where('boardId', '==', card.boardId)\n        .limit(1)\n        .get();\n      \n      if (!listsSnapshot.empty) {\n        const firstList = listsSnapshot.docs[0];\n        const listData = firstList.data();\n        const cardIds = listData.cardIds || [];\n        \n        await firstList.ref.update({\n          cardIds: [card.id, ...cardIds]\n        });\n        \n        // Update the card's listId to match its new location\n        await db.collection('cards').doc(card.id).update({\n          listId: firstList.id\n        });\n        \n        return true;\n      }\n      \n      throw new Error('No valid list found for card restoration');\n    }\n  } catch (error) {\n    console.error('Error restoring card:', error);\n    throw error;\n  }\n};\n```",
        "testStrategy": "1. Unit test the restoration function with various card and list scenarios.\n2. Test the edge case where the original list no longer exists.\n3. Verify that the card is correctly placed at the top of its list after restoration.\n4. Test error handling for database failures.\n5. Integration test to ensure the UI updates correctly after a card is restored.\n6. Verify that the card's status is correctly updated in the database.",
        "priority": "high",
        "dependencies": [36, 39],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Update Card Actions to Support Status Changes",
        "description": "Modify existing card action menus or buttons to allow users to mark cards as Done, Archive them, or Delete them.",
        "details": "Update the existing card UI to include options for changing a card's status. This could be through an existing card menu or by adding new buttons/actions. Example implementation:\n```jsx\nconst CardActions = ({ card }) => {\n  const [menuOpen, setMenuOpen] = useState(false);\n  \n  const handleStatusChange = async (newStatus) => {\n    try {\n      await updateCardStatus(card.id, newStatus);\n      setMenuOpen(false);\n      // Trigger any necessary UI updates or notifications\n    } catch (error) {\n      console.error(`Error changing card status to ${newStatus}:`, error);\n      // Show error notification\n    }\n  };\n  \n  return (\n    <div className=\"card-actions\">\n      <button \n        className=\"card-menu-button\" \n        onClick={() => setMenuOpen(!menuOpen)}\n        aria-label=\"Card actions\"\n      >\n        ⋮\n      </button>\n      \n      {menuOpen && (\n        <div className=\"card-menu\">\n          {/* Existing card actions */}\n          <button onClick={() => handleStatusChange('done')}>Mark as Done</button>\n          <button onClick={() => handleStatusChange('archived')}>Archive</button>\n          <button onClick={() => handleStatusChange('deleted')}>Delete</button>\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Helper function to update card status\nconst updateCardStatus = async (cardId, status) => {\n  try {\n    await db.collection('cards').doc(cardId).update({\n      status,\n      updatedAt: firebase.firestore.FieldValue.serverTimestamp()\n    });\n    return true;\n  } catch (error) {\n    console.error('Error updating card status:', error);\n    throw error;\n  }\n};\n```",
        "testStrategy": "1. Unit test the CardActions component with different card states.\n2. Test that clicking each status option correctly triggers the status change function.\n3. Verify that the menu opens and closes properly.\n4. Test error handling for failed status updates.\n5. Integration test to ensure the card disappears from the board when its status is changed.\n6. Verify that the UI is updated correctly after a status change.",
        "priority": "medium",
        "dependencies": [36],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "Update Board View to Filter Out Non-Active Cards",
        "description": "Modify the main board view to only display cards with 'active' status, hiding Done, Archived, and Deleted cards.",
        "details": "Update the board's card fetching logic to only retrieve and display cards with 'active' status. This will ensure that Done, Archived, and Deleted cards are hidden from the main board view. Example implementation:\n```typescript\n// Update the existing function that fetches cards for the board\nconst fetchBoardCards = async (boardId) => {\n  try {\n    const cardsRef = db.collection('cards');\n    const query = cardsRef\n      .where('boardId', '==', boardId)\n      .where('status', '==', 'active'); // Only fetch active cards\n    \n    const snapshot = await query.get();\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error fetching board cards:', error);\n    throw error;\n  }\n};\n\n// Update the board component to use this filtered query\nconst Board = ({ boardId }) => {\n  const [cards, setCards] = useState([]);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    const loadBoardData = async () => {\n      setLoading(true);\n      try {\n        const boardCards = await fetchBoardCards(boardId);\n        setCards(boardCards);\n      } catch (error) {\n        console.error('Error loading board:', error);\n        // Handle error\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    loadBoardData();\n    \n    // Set up real-time listener for card changes\n    const unsubscribe = db.collection('cards')\n      .where('boardId', '==', boardId)\n      .where('status', '==', 'active')\n      .onSnapshot(snapshot => {\n        const changes = snapshot.docChanges();\n        // Process changes and update the cards state\n        // ...\n      });\n    \n    return () => unsubscribe();\n  }, [boardId]);\n  \n  // Render the board with the filtered cards\n  // ...\n};\n```",
        "testStrategy": "1. Unit test the updated card fetching function to ensure it only returns active cards.\n2. Test the real-time listener to verify it correctly updates when cards change status.\n3. Integration test to ensure the board view updates correctly when a card's status changes.\n4. Performance test to verify that filtering doesn't negatively impact board loading time.\n5. Verify that cards with non-active statuses are properly hidden from the board view.",
        "priority": "high",
        "dependencies": [35, 38],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Implement UI Feedback for Status Changes",
        "description": "Add visual feedback when a card's status changes, such as confirmation messages or animations.",
        "details": "Implement user feedback mechanisms for status change actions to improve the user experience. This should include success/error notifications and potentially subtle animations for card transitions. Example implementation:\n```jsx\n// Toast notification component\nconst Toast = ({ message, type, onClose }) => {\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      onClose();\n    }, 3000); // Auto-close after 3 seconds\n    \n    return () => clearTimeout(timer);\n  }, [onClose]);\n  \n  return (\n    <div className={`toast ${type}`}>\n      <span>{message}</span>\n      <button onClick={onClose} aria-label=\"Dismiss notification\">×</button>\n    </div>\n  );\n};\n\n// Toast container component\nconst ToastContainer = () => {\n  const [toasts, setToasts] = useState([]);\n  \n  // Add this to your global context or use a pub/sub system\n  window.showToast = (message, type = 'info') => {\n    const id = Date.now();\n    setToasts(prev => [...prev, { id, message, type }]);\n  };\n  \n  const removeToast = (id) => {\n    setToasts(prev => prev.filter(toast => toast.id !== id));\n  };\n  \n  return (\n    <div className=\"toast-container\">\n      {toasts.map(toast => (\n        <Toast \n          key={toast.id}\n          message={toast.message}\n          type={toast.type}\n          onClose={() => removeToast(toast.id)}\n        />\n      ))}\n    </div>\n  );\n};\n\n// Usage in card status change functions\nconst handleStatusChange = async (card, newStatus) => {\n  try {\n    await updateCardStatus(card.id, newStatus);\n    \n    // Show success notification\n    const statusMessages = {\n      'done': 'Card marked as done',\n      'archived': 'Card archived',\n      'deleted': 'Card deleted',\n      'active': 'Card restored to board'\n    };\n    \n    window.showToast(statusMessages[newStatus] || 'Status updated', 'success');\n    \n    // Add animation class to the card if it's still in the DOM\n    const cardElement = document.getElementById(`card-${card.id}`);\n    if (cardElement && newStatus !== 'active') {\n      cardElement.classList.add('card-exit-animation');\n      setTimeout(() => {\n        // The card will be removed from the DOM by React when the data updates\n      }, 300); // Match this to your animation duration\n    }\n  } catch (error) {\n    console.error(`Error changing card status to ${newStatus}:`, error);\n    window.showToast(`Failed to update card: ${error.message}`, 'error');\n  }\n};\n```",
        "testStrategy": "1. Unit test the Toast and ToastContainer components.\n2. Test that notifications appear with the correct message for each status change.\n3. Verify that notifications auto-dismiss after the specified timeout.\n4. Test that animations play correctly when a card's status changes.\n5. Verify that error messages are displayed appropriately when status changes fail.\n6. Test that the UI remains responsive during status change operations.",
        "priority": "low",
        "dependencies": [42, 43],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Analyze and refactor CardDetailDialog component",
        "description": "Analyze the existing CardDetailDialog component structure and prepare it for inline editing capabilities",
        "details": "1. Review the current implementation of `components/card-detail-dialog.tsx`\n2. Identify areas where title and description are rendered\n3. Refactor the component to support state management for editing mode\n4. Create state variables for tracking edit modes (isEditingTitle, isEditingDescription)\n5. Ensure the component structure can accommodate the new UI elements\n6. Extract reusable logic from `components/edit-card-dialog.tsx` that can be used for inline editing\n7. Set up proper TypeScript interfaces for the component props and state\n8. Ensure accessibility is maintained throughout the refactoring",
        "testStrategy": "1. Create unit tests to verify the component renders correctly in both view and edit modes\n2. Test that state transitions work as expected when toggling between modes\n3. Verify that the component maintains all existing functionality\n4. Use React Testing Library to test component rendering and state management",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Implement inline title editing",
        "description": "Enable users to edit the card title directly within the card detail dialog by clicking on it",
        "details": "1. Modify the title display in `components/card-detail-dialog.tsx` to be clickable\n2. Implement a state toggle when the title is clicked to switch to edit mode\n3. Replace the title display with an input field when in edit mode\n4. Add event handlers for:\n   - Save on Enter key press\n   - Cancel on Escape key press\n   - Save on blur (clicking away)\n5. Reuse the card update logic from the existing codebase\n6. Implement optimistic UI updates for a responsive feel\n7. Add visual feedback during the saving process\n8. Handle potential errors during save operations\n9. Ensure the input field is properly styled to match the design system",
        "testStrategy": "1. Unit test the title edit functionality using React Testing Library\n2. Test all edge cases: empty titles, very long titles, special characters\n3. Test keyboard interactions (Enter to save, Escape to cancel)\n4. Test blur behavior\n5. Mock the Firebase service and verify it's called with correct parameters\n6. Test error handling scenarios\n7. Verify the UI updates optimistically before the backend confirms the change",
        "priority": "high",
        "dependencies": [45],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Implement inline description editing",
        "description": "Allow users to edit the card description directly within the card detail dialog with dedicated save and cancel buttons",
        "details": "1. Modify the description display in `components/card-detail-dialog.tsx` to be clickable\n2. Implement a state toggle when the description is clicked to switch to edit mode\n3. Replace the description display with a textarea when in edit mode\n4. Add 'Save' and 'Cancel' buttons below the textarea\n5. Implement handlers for the save and cancel actions\n6. Reuse the card update logic from the existing codebase\n7. Implement optimistic UI updates for a responsive feel\n8. Add visual feedback during the saving process\n9. Handle potential errors during save operations\n10. Ensure the textarea is properly styled and supports auto-resizing based on content\n11. Maintain markdown support if the current description supports it",
        "testStrategy": "1. Unit test the description edit functionality using React Testing Library\n2. Test all edge cases: empty descriptions, very long descriptions, markdown content\n3. Test the Save and Cancel button functionality\n4. Mock the Firebase service and verify it's called with correct parameters\n5. Test error handling scenarios\n6. Verify the UI updates optimistically before the backend confirms the change\n7. Test that the textarea properly resizes with content",
        "priority": "high",
        "dependencies": [45],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Add Archive and Delete action buttons",
        "description": "Add Archive and Delete buttons to the card detail dialog and implement their functionality",
        "details": "1. Design and add Archive and Delete buttons to the card detail dialog\n2. Position the buttons appropriately in the UI (likely in a footer or header area)\n3. Implement click handlers for both actions\n4. For Archive:\n   - Call the appropriate function from `lib/firebase-service.ts`\n   - Close the dialog after successful archiving\n   - Update the board UI to remove the archived card\n5. For Delete:\n   - Implement a confirmation dialog using a modal or toast\n   - Only proceed with deletion after user confirmation\n   - Call the appropriate function from `lib/firebase-service.ts`\n   - Close the dialog after successful deletion\n   - Update the board UI to remove the deleted card\n6. Add appropriate visual styling and hover states for the buttons\n7. Include proper icons for each action",
        "testStrategy": "1. Unit test the presence and styling of the action buttons\n2. Test the click handlers for both buttons\n3. For Delete, test that the confirmation dialog appears and works correctly\n4. Mock the Firebase service and verify it's called with correct parameters\n5. Test that the dialog closes after successful operations\n6. Verify the board UI updates correctly after operations\n7. Test error handling scenarios",
        "priority": "high",
        "dependencies": [45],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Implement Mark as Done functionality",
        "description": "Add a Mark as Done button to the card detail dialog to allow users to quickly change a card's status",
        "details": "1. Design and add a Mark as Done button to the card detail dialog\n2. Position the button appropriately in the UI\n3. Implement a click handler for the action\n4. Determine the current status of the card and toggle it appropriately\n5. Call the appropriate function from `lib/firebase-service.ts` to update the card status\n6. Implement optimistic UI updates for a responsive feel\n7. Add visual feedback during the saving process\n8. Handle potential errors during save operations\n9. Consider making this a toggle button that shows different text based on current status (e.g., 'Mark as Done' vs 'Mark as To Do')\n10. Add appropriate visual styling and hover states for the button",
        "testStrategy": "1. Unit test the presence and styling of the Mark as Done button\n2. Test the click handler functionality\n3. Test that the button text/appearance changes based on the card's current status\n4. Mock the Firebase service and verify it's called with correct parameters\n5. Verify the UI updates optimistically before the backend confirms the change\n6. Test error handling scenarios",
        "priority": "medium",
        "dependencies": [45, 48],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Implement offline editing support",
        "description": "Enable users to edit cards while offline with appropriate caching and synchronization when connection is restored",
        "details": "1. Implement a connection status detector using browser APIs (navigator.onLine and related events)\n2. Create a local cache mechanism for storing edits made while offline\n3. When a user attempts to save changes while offline:\n   - Store the changes in local storage or IndexedDB\n   - Show a visual indicator that the changes are pending sync\n   - Add the change to a queue of pending operations\n4. When the connection is restored:\n   - Detect the online status change\n   - Process the queue of pending operations\n   - Update the UI as operations succeed or fail\n   - Show appropriate notifications to the user\n5. Handle conflict resolution using a 'last-write-wins' strategy as specified in the PRD\n6. Implement appropriate error handling for failed synchronizations\n7. Consider using a library like Workbox for offline support if appropriate",
        "testStrategy": "1. Test the connection status detection mechanism\n2. Test the local caching of edits while offline\n3. Test the synchronization process when connection is restored\n4. Simulate various network conditions to verify robustness\n5. Test conflict resolution scenarios\n6. Verify that appropriate notifications are shown to the user\n7. Test that the UI correctly reflects the sync status of changes",
        "priority": "medium",
        "dependencies": [46, 47, 48, 49],
        "status": "deferred",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Implement permissions handling",
        "description": "Ensure that editing capabilities are only available to users with appropriate permissions",
        "details": "1. Review the existing permissions model in the application\n2. Modify the CardDetailDialog component to check user permissions before showing edit controls\n3. Implement conditional rendering of edit functionality based on permissions\n4. Add appropriate error handling for cases where a user without permissions attempts to edit\n5. Create clear error messages for permission-related issues\n6. Ensure that the Firebase security rules in `firestore.rules` are respected\n7. Add client-side validation to prevent unauthorized edit attempts\n8. Handle API errors related to permissions gracefully with user-friendly messages",
        "testStrategy": "1. Test rendering of the component with different user permission levels\n2. Verify that edit controls are only visible to users with appropriate permissions\n3. Test error handling when unauthorized edit attempts occur\n4. Mock different permission scenarios and verify the component behaves correctly\n5. Test integration with Firebase security rules\n6. Verify that appropriate error messages are shown to users without permissions",
        "priority": "high",
        "dependencies": [46, 47, 48],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Implement concurrent editing notifications",
        "description": "Add notifications to inform users when another user has made changes to the card they are viewing",
        "details": "1. Implement a mechanism to detect when a card has been modified by another user\n2. This could use Firestore's real-time capabilities to listen for document changes\n3. When a change is detected while a user is viewing a card:\n   - Show a non-intrusive notification (toast or banner)\n   - Inform the user that the card has been updated\n   - Offer an option to refresh the view with the latest data\n4. Implement the refresh functionality to update the card data\n5. Ensure the notification is dismissible\n6. Handle edge cases such as multiple rapid updates\n7. Consider implementing a cooldown period for notifications to prevent spam\n8. This is a 'nice-to-have' feature as specified in the PRD",
        "testStrategy": "1. Test the change detection mechanism using mock Firestore events\n2. Verify that notifications appear correctly when changes are detected\n3. Test the refresh functionality to ensure it updates the card data\n4. Test edge cases like multiple rapid updates\n5. Verify that notifications are dismissible\n6. Test the integration with Firestore's real-time capabilities",
        "priority": "low",
        "dependencies": [46, 47, 48, 49],
        "status": "deferred",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Implement comprehensive error handling",
        "description": "Create a robust error handling system for all card editing operations",
        "details": "1. Identify all possible error scenarios in the card editing workflow\n2. Implement appropriate error handling for each scenario:\n   - Network errors\n   - Permission errors\n   - Validation errors\n   - Concurrent editing conflicts\n   - Server errors\n3. Create user-friendly error messages for each error type\n4. Use the existing `use-toast.ts` hook to display error notifications\n5. Implement retry mechanisms where appropriate\n6. Preserve user input when errors occur to prevent data loss\n7. Log errors appropriately for debugging purposes\n8. Consider implementing a global error boundary for unexpected errors",
        "testStrategy": "1. Test each identified error scenario to verify proper handling\n2. Verify that appropriate error messages are displayed to users\n3. Test retry mechanisms where implemented\n4. Verify that user input is preserved when errors occur\n5. Test integration with the toast notification system\n6. Simulate various error conditions to ensure robustness",
        "priority": "medium",
        "dependencies": [46, 47, 48, 49, 50],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "Conduct comprehensive testing and performance optimization",
        "description": "Perform thorough testing of all implemented features and optimize performance to meet the sub-500ms response requirement",
        "details": "1. Create a comprehensive test plan covering all implemented features\n2. Implement end-to-end tests using Cypress or a similar tool\n3. Conduct performance testing to ensure all operations complete within 500ms as specified in the PRD\n4. Optimize component rendering using React best practices:\n   - Memoization with useMemo and useCallback\n   - Proper use of React.memo for component memoization\n   - Efficient state management\n5. Implement performance monitoring to track response times\n6. Optimize Firebase queries and updates\n7. Implement loading states and skeletons for operations that might take time\n8. Test on various devices and network conditions\n9. Address any accessibility issues identified during testing\n10. Document any performance optimizations for future reference",
        "testStrategy": "1. Run the comprehensive test suite covering all features\n2. Conduct performance testing using browser dev tools and custom timing measurements\n3. Test on various devices and network conditions including throttled connections\n4. Use Lighthouse or similar tools to assess performance metrics\n5. Verify that all operations meet the sub-500ms requirement specified in the PRD\n6. Test accessibility using automated tools and manual testing",
        "priority": "medium",
        "dependencies": [46, 47, 48, 49, 50, 51, 52, 53],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "Improve discoverability of UI actions and shortcuts",
        "description": "Investigate and implement UI patterns to improve the discoverability of non-obvious features and actions. This includes keyboard shortcuts like Cmd+Enter and actions hidden in menus.",
        "details": "1. Identify features lacking visual discoverability.\n2. Research and propose UI solutions like tooltips, help dialogs, or subtle UI hints.",
        "testStrategy": "",
        "status": "deferred",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 56,
        "title": "Refactor Card Actions into Kebab Menu",
        "description": "Replace the action buttons in the card detail dialog with a cleaner kebab menu.",
        "details": "1. Remove the DialogFooter containing the Archive, Delete, and Mark as Done buttons from CardDetailDialog.tsx.\n2. Add a MoreVertical icon button to the DialogHeader, aligned to the right.\n3. Use the DropdownMenu component from shadcn/ui to create the menu.\n4. Add DropdownMenuItems for 'Mark as Done'/'Mark as Active', 'Archive', and 'Delete'.\n5. Connect the existing handler functions to these new menu items.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 57,
        "title": "Implement Universal Cmd+Enter Save Shortcut",
        "description": "Implement Cmd+Enter (or Ctrl+Enter) as a universal shortcut for saving changes in editable fields.",
        "details": "1. In CardDetailDialog.tsx, modify the onKeyDown handler for the title Input.\n   - It should now save only on Cmd/Ctrl+Enter or blur.\n   - Pressing Enter alone should do nothing.\n2. Modify the onKeyDown handler for the description Textarea.\n   - It should save on Cmd/Ctrl+Enter.\n   - Pressing Enter alone should continue to create a new line.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 58,
        "title": "Research and Implement a Firestore Mocking Library",
        "description": "Our current test setup uses a manual, ad-hoc mock for Firestore. This can be brittle and hard to maintain. This task is to research, select, and implement a dedicated Firestore mocking library to improve test reliability.",
        "details": "1. Investigate modern libraries for mocking Firestore in a Vitest environment (e.g., firestore-jest-mock, @firebase/rules-unit-testing, or others).\n2. Select the most suitable library based on features, maintenance, and compatibility.\n3. Refactor `vitest.setup.ts` to replace the manual Firestore mock with the new library.\n4. Update existing tests that rely on the old mock to use the new library's API.",
        "testStrategy": "",
        "status": "deferred",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 59,
        "title": "Implement Keyboard Shortcuts in Comment Form",
        "description": "Refactor `components/comment-form.tsx` to add keyboard shortcuts. `Ctrl/Cmd + Enter` will submit the comment. `Escape` will clear the comment textarea. This ensures consistency with other editable fields in the application.",
        "details": "- Extract submission logic from `handleSubmit` into a new `submitComment` function.\n- The `form`'s `onSubmit` handler should call `e.preventDefault()` and then `submitComment`.\n- Add an `onKeyDown` handler to the `Textarea`.\n- In `onKeyDown`, if `Ctrl/Cmd + Enter` is pressed, call `submitComment` and `e.preventDefault()`.\n- In `onKeyDown`, if `Escape` is pressed, clear the content state and call `e.stopPropagation()` to prevent the dialog from closing.",
        "testStrategy": "Manual testing: Open the card detail dialog. \n1. Type a comment and press `Ctrl/Cmd + Enter` to verify it's submitted. \n2. Type a comment and press `Escape` to verify the field is cleared and the dialog remains open. \n3. Verify that pressing `Enter` alone creates a new line.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 60,
        "title": "Add Escape Key Handling to Card Description Editing",
        "description": "In `components/card-detail-dialog.tsx`, the description `Textarea` does not handle the `Escape` key to cancel editing. This is inconsistent with the title editing. This task is to add an `onKeyDown` handler to the description `Textarea` to cancel the edit on `Escape`.",
        "details": "- In `components/card-detail-dialog.tsx`, locate the `Textarea` for the description.\n- Add an `onKeyDown` handler.\n- Inside the handler, check for the `Escape` key.\n- If `Escape` is pressed, call `setIsEditingDescription(false)` and reset the `description` state to `card.description || ''`.\n- It may be necessary to call `e.stopPropagation()` to prevent the dialog from closing.",
        "testStrategy": "Manual testing: \n1. Open a card and click to edit the description. \n2. Type something. \n3. Press `Escape`. \n4. Verify that the edit mode is cancelled, the changes are discarded, and the dialog is still open.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 61,
        "title": "Audit Data-Entry Fields for Keyboard Shortcut Consistency",
        "description": "Review all input fields, textareas, and forms in the application. Ensure that `Ctrl/Cmd + Enter` is consistently used for submission and `Escape` is used for cancellation of an edit. This audit should cover all dialogs and inline editing components.",
        "details": "- Identify all components with data entry fields (e.g., `create-board-dialog`, `create-list-dialog`, `create-card-dialog`, `edit-board-dialog`, etc.).\n- For each component, check the behavior of `Enter`, `Ctrl/Cmd + Enter`, and `Escape`.\n- Create a list of components that are inconsistent.\n- For each inconsistency, create a new task with details on how to fix it.",
        "testStrategy": "Manual testing across all forms and editable fields in the application. Create a checklist of components to review.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 62,
        "title": "Add Ctrl/Cmd+Enter Shortcut to Description Fields in Dialogs",
        "description": "In several dialogs, the `description` Textarea does not submit the form on `Ctrl/Cmd + Enter`. This is inconsistent with other parts of the application. This task is to add this keyboard shortcut to the description Textarea in the identified components.",
        "details": "Update the following files:\n- `components/create-board-dialog.tsx`\n- `components/create-card-dialog.tsx`\n- `components/edit-board-dialog.tsx`\n- `components/edit-card-dialog.tsx`\n\nFor each file, add an `onKeyDown` handler to the description `Textarea`. The handler should check for `Ctrl/Cmd + Enter` and, if detected, it should programmatically submit the form.",
        "testStrategy": "For each of the four dialogs: \n1. Open the dialog. \n2. Fill in the title. \n3. Type a description. \n4. Press `Ctrl/Cmd + Enter` while focused on the description field. \n5. Verify that the form is submitted successfully.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 63,
        "title": "Automate App Version Bumping and Display in UI",
        "description": "Create a process to automatically increment the application version in `package.json` upon release. Also, make the current app version visible somewhere in the UI, like the footer or a settings page, for easier debugging and user reference.",
        "details": "- Investigate tools for automating version bumps (e.g., `npm version`, `standard-version`).\n- Integrate the chosen tool into the release workflow (e.g., as a git hook or a release script).\n- Expose the version from `package.json` to the Next.js frontend (e.g., via build-time environment variables).\n- Add a small UI element to display the application version.",
        "testStrategy": "- Verify that the version bump script correctly increments the version in `package.json`.\n- Confirm that the new version is visible in the UI after a build.",
        "status": "deferred",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 64,
        "title": "Add Double-Click Shortcut to Edit List Title",
        "description": "Implement a shortcut to allow users to edit a list's title by double-clicking it. This improves user experience by providing a faster way to rename lists. The `Escape` key should cancel the edit.",
        "details": "In `components/list-column.tsx`, add an `onDoubleClick` handler to the list title element. This handler should set the component into its 'isEditing' state. The existing `handleCancelEdit` function, which is triggered by `Escape`, will handle cancellation.",
        "testStrategy": "1. Go to a board view.\n2. Double-click on a list's title.\n3. Verify that the title turns into an input field.\n4. Press `Escape` and verify the edit is cancelled.\n5. Double-click again, change the name, and press `Enter`. Verify the list title is updated.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 65,
        "title": "Fix Horizontal Overflow in Status View Modal",
        "description": "The modal that displays 'Done', 'Archived', or 'Deleted' cards has a horizontal overflow issue, forcing users to scroll right to see card content and actions. This task is to apply styling to constrain the width of the cards within the modal and ensure their content wraps correctly.",
        "details": "1. Identify the component responsible for rendering the status view modal (likely `view-status-dialog.tsx`).\n2. Analyze the CSS causing the card elements to overflow their container.\n3. Apply styles (e.g., `max-width`, `overflow-wrap: break-word`) to the card components within the modal to ensure they fit within the viewport without horizontal scrolling.",
        "testStrategy": "1. Open the 'Done Cards' view (or Archived/Deleted).\n2. Verify that the cards are contained within the modal without causing horizontal scrollbars.\n3. Ensure the card titles and content wrap correctly.\n4. Check that the 'View' and 'Restore' buttons are always visible.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 66,
        "title": "Implement Draggable Reordering for Lists",
        "description": "Allow users to reorder lists horizontally on the board page using drag-and-drop.",
        "status": "done",
        "dependencies": [73],
        "priority": "low",
        "details": "Using the existing `@atlaskit/pragmatic-drag-and-drop` library, implement the necessary draggable and drop-target adapters for the list columns. The implementation will follow the new architecture of using separate, dedicated elements for different drag-and-drop interactions within the ListColumn component. The `onDrop` handler will need to call a new `listService` function to persist the new order in Firestore. This work will begin after the card-dragging regression is fixed.",
        "testStrategy": "1. Test that lists can be dragged and reordered horizontally\n2. Verify that the new order is correctly persisted in Firestore\n3. Test edge cases like dragging the first list to the end and vice versa\n4. Ensure the UI updates immediately to reflect the new order before the backend sync completes",
        "subtasks": []
      },
      {
        "id": 67,
        "title": "Implement Draggable Reordering for Boards",
        "description": "Allow users to reorder their boards on the main dashboard using drag-and-drop. Note: Exploring alternative organization methods beyond simple drag-and-drop reordering.",
        "status": "deferred",
        "dependencies": [],
        "priority": "low",
        "details": "Using the existing `@atlaskit/pragmatic-drag-and-drop` library, implement the necessary draggable and drop-target adapters for the board cards on the dashboard. The `onDrop` handler will need to call a new `boardService` function to persist the new order in Firestore.\n\nAlternative organization methods to consider:\n1. Multi-board 'workspaces' - Allow users to group related boards into workspaces for better organization\n2. 'Starred boards' feature - Enable users to mark favorite boards for quick access\n3. Tagging/categorization system - Let users apply tags to boards for filtering and organization",
        "testStrategy": "If implemented, test both the drag-and-drop functionality and any alternative organization methods selected.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Research and evaluate alternative board organization methods (workspaces, starred boards, tagging)",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Create mockups for the preferred organization method(s)",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Gather user feedback on organization preferences before implementation",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 68,
        "title": "Create Reusable Skeleton Components",
        "description": "Create reusable skeleton placeholder components for card items and comment items. These will be used to prevent layout shift when loading asynchronous data in modals.",
        "details": "1. Create a new file `components/ui/skeleton.tsx` if it doesn't exist (based on shadcn/ui skeleton). \n2. Create a `CardSkeleton.tsx` component that visually mimics the layout and height of a card item shown in the `view-status-dialog.tsx`.\n3. Create a `CommentSkeleton.tsx` component that visually mimics the layout and height of a `comment-item.tsx`.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 69,
        "title": "Integrate Skeleton Loaders into Modals",
        "description": "Integrate the new skeleton components into the loading states of the `view-status-dialog` and `card-detail-dialog` to prevent layout shift.",
        "details": "1. In `view-status-dialog.tsx`, replace the `<LoadingSpinner />` with a list of `CardSkeleton` components when cards are being fetched.\n2. In `card-detail-dialog.tsx` (or its `comments-section.tsx` child), replace the loading state with a list of `CommentSkeleton` components when comments are being fetched.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 70,
        "title": "Implement Fixed-Top Positioning for Modals",
        "description": "Modify the styling of the main Dialog component to anchor it to the top of the viewport, preventing vertical movement when content changes.",
        "details": "1. Investigate the `shadcn/ui` Dialog component structure.\n2. Apply Tailwind CSS classes to the `DialogContent` component to override the default centering behavior.\n3. The goal is to align the modal to the top of the viewport (e.g., `top-0 translate-y-0` or similar) so that it only expands downwards.\n4. Test thoroughly to ensure this change doesn't negatively affect other dialog features or responsiveness.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 71,
        "title": "Fix Modal Width Blink on Scrollbar Appearance",
        "description": "When content in a modal is long enough to require a vertical scrollbar, the appearance of the scrollbar causes a horizontal 'blink' or layout shift. This task is to fix this by ensuring space is always reserved for the scrollbar.",
        "details": "In `card-detail-dialog.tsx` and `view-status-dialog.tsx`, find the elements styled with `overflow-y-auto` and change the class to `overflow-y-scroll`. This will prevent the content width from changing when the scrollbar appears.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 72,
        "title": "Improve Card Drag-and-Drop UX with Placeholder",
        "description": "Refactor the card drag-and-drop interaction to use a full-size placeholder (a 'ghost' card) instead of a simple drop indicator line. This will make the drop target clearer and prevent the list from resizing during reordering, creating a more stable and intuitive user experience.",
        "status": "done",
        "dependencies": [73],
        "priority": "high",
        "details": "1. Modify the drag-and-drop logic for cards, likely in `list-column.tsx` and `card-item.tsx`.\n2. Instead of rendering a `<DropIndicator />`, render a placeholder component (`CardSkeleton` or a new `CardPlaceholder`) that has the same dimensions as the card being dragged.\n3. The placeholder should appear in the list at the potential drop position.\n4. Ensure the list's size does not change while reordering a card within it.",
        "testStrategy": "",
        "subtasks": []
      },
      {
        "id": 73,
        "title": "fix(dnd): Restore broken card drag-and-drop functionality",
        "description": "A recent change to implement list dragging has introduced a regression that broke the existing card drag-and-drop feature. This task is to fix the regression by refactoring the `ListColumn` component to use separate elements for card drop targets and list drag sources, restoring the original card reordering functionality.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 74,
        "title": "Standardize Confirmation Dialog Across Card Components",
        "description": "Refactor card-related components to use a single, reusable confirmation dialog component instead of inconsistent approaches (custom AlertDialog vs window.confirm) to ensure UI consistency.",
        "details": "This task involves identifying and standardizing the confirmation dialog pattern used across card components:\n\n1. Review the existing confirmation dialog implementations:\n   - `board-card.tsx` uses a custom `AlertDialog` for confirming card deletion\n   - `card-detail-dialog.tsx` uses the browser's default `window.confirm`\n\n2. Create a reusable confirmation dialog component:\n   ```tsx\n   // components/ui/confirmation-dialog.tsx\n   import {\n     AlertDialog,\n     AlertDialogAction,\n     AlertDialogCancel,\n     AlertDialogContent,\n     AlertDialogDescription,\n     AlertDialogFooter,\n     AlertDialogHeader,\n     AlertDialogTitle,\n   } from \"@/components/ui/alert-dialog\";\n\n   interface ConfirmationDialogProps {\n     isOpen: boolean;\n     onClose: () => void;\n     onConfirm: () => void;\n     title: string;\n     description: string;\n     confirmLabel?: string;\n     cancelLabel?: string;\n   }\n\n   export function ConfirmationDialog({\n     isOpen,\n     onClose,\n     onConfirm,\n     title,\n     description,\n     confirmLabel = \"Confirm\",\n     cancelLabel = \"Cancel\",\n   }: ConfirmationDialogProps) {\n     return (\n       <AlertDialog open={isOpen} onOpenChange={onClose}>\n         <AlertDialogContent>\n           <AlertDialogHeader>\n             <AlertDialogTitle>{title}</AlertDialogTitle>\n             <AlertDialogDescription>{description}</AlertDialogDescription>\n           </AlertDialogHeader>\n           <AlertDialogFooter>\n             <AlertDialogCancel>{cancelLabel}</AlertDialogCancel>\n             <AlertDialogAction onClick={onConfirm}>{confirmLabel}</AlertDialogAction>\n           </AlertDialogFooter>\n         </AlertDialogContent>\n       </AlertDialog>\n     );\n   }\n   ```\n\n3. Refactor `board-card.tsx` to use the new component:\n   - Replace the existing AlertDialog implementation with the new ConfirmationDialog\n   - Ensure all functionality remains the same\n\n4. Refactor `card-detail-dialog.tsx` to use the new component:\n   - Replace all instances of `window.confirm` with the new ConfirmationDialog\n   - Add state management for controlling dialog visibility\n   - Update the component to handle the dialog open/close states\n\n5. Review other components in the application that might use confirmation dialogs:\n   - Identify any other components using either AlertDialog or window.confirm for similar purposes\n   - Refactor them to use the new ConfirmationDialog component\n\n6. Update any related tests to reflect the new implementation\n\n7. Document the new ConfirmationDialog component and its usage pattern for future development",
        "testStrategy": "1. Unit test the new ConfirmationDialog component:\n   - Test that it renders correctly with default props\n   - Test that it renders with custom labels\n   - Test that onConfirm and onClose callbacks are triggered correctly\n\n2. Integration test the refactored components:\n   - Verify that `board-card.tsx` still functions correctly with the new dialog\n   - Verify that `card-detail-dialog.tsx` shows the custom dialog instead of window.confirm\n   - Test that confirmation and cancellation work as expected in both components\n\n3. Visual regression testing:\n   - Compare screenshots before and after the refactoring to ensure UI consistency\n   - Verify that the dialog appears correctly on different screen sizes\n\n4. Accessibility testing:\n   - Test keyboard navigation within the dialog\n   - Verify that focus is properly trapped within the dialog when open\n   - Check that screen readers can properly announce the dialog content\n\n5. Cross-browser testing:\n   - Verify the dialog works consistently across Chrome, Firefox, Safari, and Edge\n\n6. Manual testing checklist:\n   - Confirm that deleting a card from board view works correctly\n   - Confirm that deleting a card from detail view works correctly\n   - Verify that other actions using the confirmation dialog work as expected\n   - Check that the dialog appears centered and properly styled in all contexts",
        "status": "done",
        "dependencies": [39, 40, 53],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 75,
        "title": "Fix Firebase Mock Configuration",
        "description": "Resolve CommonJS/ESM import conflicts in Firebase mock setup",
        "details": "Convert `lib/firebase.ts` to use dynamic ESM imports or move mock setup to test configuration. Update `vitest.setup.ts` and `lib/__mocks__/` accordingly.",
        "testStrategy": "Verify that tests execute without import errors",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 76,
        "title": "Add Missing Dependencies",
        "description": "Ensure all required packages are installed and configured",
        "details": "Audit and install missing dependencies like `tiny-invariant`. Update `package.json` and run dependency audits.",
        "testStrategy": "Verify that all tests can import dependencies without errors",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 77,
        "title": "Update Vitest Configuration",
        "description": "Fix Vitest mock hoisting and module resolution issues",
        "details": "Update `vitest.config.ts` to handle ESM properly and ensure correct mock configuration.",
        "testStrategy": "Run tests to ensure no configuration errors occur",
        "priority": "high",
        "dependencies": [75, 76],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 78,
        "title": "Restore Basic Test Execution",
        "description": "Ensure tests run without errors after initial fixes",
        "details": "Run a full test suite to verify that basic tests execute without errors.",
        "testStrategy": "Verify that at least some tests pass without errors",
        "priority": "high",
        "dependencies": [75, 76, 77],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 79,
        "title": "Create Test Wrapper Utilities",
        "description": "Develop comprehensive test wrappers for context providers",
        "details": "Create utilities in `vitest.setup.ts` and test utility files to provide BoardContext, ColumnContext, and authentication context.",
        "testStrategy": "Verify that context-dependent tests run without errors",
        "priority": "high",
        "dependencies": [78],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 80,
        "title": "Fix Context-Dependent Component Tests",
        "description": "Ensure all component tests have proper context setup",
        "details": "Update all component tests to use the new test wrapper utilities.",
        "testStrategy": "Verify that all context-dependent tests pass",
        "priority": "high",
        "dependencies": [79],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 81,
        "title": "Audit and Fix Existing Tests",
        "description": "Review each test file against current component implementations",
        "details": "Update tests in all 8 test files to match current application architecture.",
        "testStrategy": "Verify that previously passing tests are restored",
        "priority": "medium",
        "dependencies": [80],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 82,
        "title": "Standardize Test Patterns",
        "description": "Update test patterns for context providers and mocking",
        "details": "Create standardized test utilities in `lib/__tests__/test-utils.ts` for mocking and context providers.",
        "testStrategy": "Verify that tests use standardized patterns",
        "priority": "medium",
        "dependencies": [81],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 83,
        "title": "Add Missing Component Tests",
        "description": "Add comprehensive tests for new components",
        "details": "Focus on components like `create-board-dialog.tsx`, `create-list-dialog.tsx`, `reparent-card-dialog.tsx`, and `view-status-dialog.tsx`.",
        "testStrategy": "Verify that new tests pass and cover required functionality",
        "priority": "medium",
        "dependencies": [82],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 87,
        "title": "Update Testing Documentation",
        "description": "Align `testing.md` with current test infrastructure",
        "details": "Document new testing patterns, utilities, and workflows in `testing.md`.",
        "testStrategy": "Verify that documentation reflects current test setup",
        "priority": "low",
        "dependencies": [86],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 88,
        "title": "Enhance Mock Strategies",
        "description": "Improve Firebase and context mocking patterns",
        "details": "Refine mocking at the service layer and context providers for better test reliability.",
        "testStrategy": "Verify that improved mocks enhance test stability",
        "priority": "low",
        "dependencies": [87],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 89,
        "title": "Optimize Test Performance",
        "description": "Reduce test execution time",
        "details": "Analyze and optimize test execution to achieve faster test runs.",
        "testStrategy": "Verify that test execution time is under 30 seconds",
        "priority": "low",
        "dependencies": [88],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-02T16:14:13.391Z",
      "updated": "2025-10-23T00:08:54.708Z",
      "description": "Tasks for master context"
    }
  },
  "shared-boards": {
    "tasks": [
      {
        "id": 1,
        "title": "Design and implement database schema changes for multi-user support",
        "description": "Create the necessary database schema modifications to support multiple users collaborating on boards, including BoardMembership and Role models.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. Design a `BoardMembership` model that creates a many-to-many relationship between Users and Boards. Each membership should include: userId, boardId, role (enum: 'OWNER', 'EDITOR').\n2. The `Role` model should be implemented as an enum with initial values of 'OWNER' and 'EDITOR'.\n3. Modify the existing Board model to include a reference to the owner (the original creator).\n4. Implement appropriate database indexes for efficient queries.\n5. Create migration scripts for existing data to ensure backward compatibility.\n\nPseudo-code for BoardMembership model in Firebase:\n```\ninterface BoardMembership {\n  id: string;\n  userId: string;\n  boardId: string;\n  role: 'OWNER' | 'EDITOR';\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n}\n```",
        "testStrategy": "1. Unit test the new models to ensure they can be created/updated/deleted correctly.\n2. Test with mock data to ensure relationships are correctly established between users and boards.\n3. Verify that queries retrieving boards for a specific user return expected results.\n4. Test permission-based scenarios to ensure proper role enforcement.\n5. Validate migration of existing data.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Database Models and TypeScript Interfaces for Multi-User Support",
            "description": "Define the necessary TypeScript interfaces and implement the database models to support multi-user collaboration on boards, including BoardMembership model and Role enum.",
            "dependencies": [],
            "details": "1. Create TypeScript interface for 'Role' enum in lib/types.ts:\nexport type BoardRole = 'OWNER' | 'EDITOR';\n\n2. Create TypeScript interface for BoardMembership in lib/types.ts:\nexport interface BoardMembership {\n  id: string;\n  userId: string;\n  boardId: string;\n  role: BoardRole;\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n}\n\n3. Update the Board interface to include an ownerUserId field:\nexport interface Board {\n  // existing fields\n  ownerUserId: string; // Add this new field\n  // other existing fields\n}\n\n4. Create database indexes for efficient queries:\n   - Create an index on BoardMembership collection for (userId, boardId)\n   - Create an index on BoardMembership collection for (boardId, role)\n\n5. Implement any necessary helper functions for creating and managing these models in your database layer.",
            "status": "done",
            "testStrategy": "1. Write unit tests to verify the TypeScript interfaces provide proper type checking\n2. Test the creation, reading, updating, and deletion of BoardMembership objects in the database\n3. Verify that indexes are properly working by analyzing query performance\n4. Test that the Board model correctly handles the new ownerUserId field"
          },
          {
            "id": 2,
            "title": "Implement Database Migration Scripts and Update Security Rules",
            "description": "Create migration scripts to update existing data to the new schema and update Firestore security rules to enforce proper access control based on the new BoardMembership model.",
            "dependencies": [],
            "details": "1. Create a migration script to update existing Boards:\nasync function migrateExistingBoards() {\n  const boards = await db.collection('boards').get();\n  \n  const batch = db.batch();\n  for (const boardDoc of boards.docs) {\n    const board = boardDoc.data();\n    \n    // Assuming boards currently have a userId field indicating the creator\n    const ownerUserId = board.userId || board.createdBy;\n    \n    // Update board to include ownerUserId\n    batch.update(boardDoc.ref, { ownerUserId });\n    \n    // Create BoardMembership for the owner\n    const membershipRef = db.collection('board_memberships').doc();\n    batch.set(membershipRef, {\n      id: membershipRef.id,\n      boardId: boardDoc.id,\n      userId: ownerUserId,\n      role: 'OWNER',\n      createdAt: admin.firestore.FieldValue.serverTimestamp(),\n      updatedAt: admin.firestore.FieldValue.serverTimestamp()\n    });\n  }\n  \n  return batch.commit();\n}\n\n2. Update Firestore security rules (firestore.rules) to implement access control:\n// Define rules for the board_memberships collection\nmatch /board_memberships/{membershipId} {\n  allow read: if request.auth != null && \n    resource.data.userId == request.auth.uid;\n  \n  // Only allow creation if the user is adding themselves with proper validation\n  allow create: if request.auth != null && \n    request.resource.data.userId == request.auth.uid &&\n    exists(/databases/$(database)/documents/boards/$(request.resource.data.boardId));\n  \n  // Only allow the board owner to add/update other users' memberships\n  allow create, update, delete: if request.auth != null && \n    getBoardOwner(request.resource.data.boardId) == request.auth.uid;\n}\n\n// Update the rules for the boards collection\nmatch /boards/{boardId} {\n  // Helper function to get board owner\n  function getBoardOwner(boardId) {\n    return get(/databases/$(database)/documents/boards/$(boardId)).data.ownerUserId;\n  }\n  \n  // Helper function to check if user is a board member\n  function isBoardMember(boardId, userId) {\n    return exists(/databases/$(database)/documents/board_memberships/$(boardId + '_' + userId));\n  }\n  \n  // Allow read if user is a member\n  allow read: if request.auth != null && \n    (resource.data.ownerUserId == request.auth.uid || \n     isBoardMember(boardId, request.auth.uid));\n  \n  // Allow create for any authenticated user (they become the owner)\n  allow create: if request.auth != null && \n    request.resource.data.ownerUserId == request.auth.uid;\n  \n  // Allow update if user is a member (specific field restrictions can be added)\n  allow update: if request.auth != null && \n    (resource.data.ownerUserId == request.auth.uid || \n     isBoardMember(boardId, request.auth.uid));\n  \n  // Allow delete only for the board owner\n  allow delete: if request.auth != null && \n    resource.data.ownerUserId == request.auth.uid;\n}\n\n3. Create a script to apply these migrations and validate the results:\nasync function applyMigrations() {\n  try {\n    console.log('Starting database migration for multi-user support...');\n    await migrateExistingBoards();\n    console.log('Successfully migrated boards to new schema');\n    \n    // Validate migration\n    await validateMigration();\n    \n    console.log('Migration completed successfully');\n  } catch (error) {\n    console.error('Migration failed:', error);\n    // Add rollback mechanism if possible\n  }\n}",
            "status": "done",
            "testStrategy": "1. Create test boards and users to verify migration script works correctly\n2. Test rollback capability for the migration script\n3. Verify that Firestore security rules properly allow/deny operations based on user roles\n4. Test edge cases in security rules, such as:\n   - A user trying to access a board they don't have access to\n   - A non-owner trying to delete a board\n   - An editor trying to update board content\n5. Perform integration tests to ensure the entire authentication and authorization flow works"
          }
        ]
      },
      {
        "id": 2,
        "title": "Update backend API to support board sharing and permissions",
        "description": "Modify existing API endpoints to utilize the new database schema and enforce role-based access control.",
        "status": "done",
        "dependencies": [1],
        "priority": "high",
        "details": "1. Update all Board-related API endpoints to check for user permissions before allowing operations.\n2. Implement a middleware or service layer that verifies a user's role for a board.\n3. Modify board retrieval endpoints to include boards where the user is a member (not just owner).\n4. Enforce that only owners can delete boards or modify board settings.\n5. Ensure that editors can create/edit/move cards and lists.\n\nPseudo-code for permission middleware:\n```\nasync function verifyBoardAccess(req, res, next) {\n  const { boardId } = req.params;\n  const userId = req.user.id;\n  \n  const membership = await BoardMemberships.findOne({ boardId, userId });\n  \n  if (!membership) {\n    return res.status(403).json({ error: 'Access denied' });\n  }\n  \n  req.userRole = membership.role;\n  next();\n}\n```",
        "testStrategy": "1. Create unit tests for the middleware/service layer that handles permissions.\n2. For each API endpoint, test access with different user roles (owner, editor, non-member).\n3. Verify that operations are correctly allowed or denied based on role.\n4. Test error handling for unauthorized access attempts.\n5. Perform integration tests that simulate real user flows.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Board Access Middleware and Helper Functions",
            "description": "Create middleware and helper functions to verify user roles and board access permissions.",
            "dependencies": [],
            "details": "Create the verifyBoardAccess middleware as shown in the pseudo-code. Implement the getBoardRole helper function to retrieve a user's role for a specific board. Implement the isBoardMember helper function to check if a user has any access to a board. Add proper error handling in the middleware to return appropriate HTTP status codes. Ensure these functions use the board_memberships table from the new database schema.",
            "status": "done",
            "testStrategy": "Write unit tests for the middleware with various scenarios (owner access, editor access, no access). Test helper functions with different user and board combinations. Verify error handling works correctly for unauthorized access attempts."
          },
          {
            "id": 2,
            "title": "Update Board Retrieval Endpoints",
            "description": "Modify board retrieval endpoints to include boards where the user is a member, not just the owner.",
            "dependencies": ["2.1"],
            "details": "Update the getUserBoards function in firebase-service.ts to query both owned boards and shared boards via the board_memberships table. Modify the response structure to include the user's role for each board. Ensure the API maintains backward compatibility. Add pagination if needed for users with many boards. Consider adding filtering options (e.g., owned boards only, shared boards only).",
            "status": "done",
            "testStrategy": "Test the endpoint with users who have a mix of owned and shared boards. Verify all expected boards are returned with correct role information. Test with users who have no boards or only one type of board access. Benchmark performance for users with many boards."
          },
          {
            "id": 3,
            "title": "Enforce Role-Based Permissions in Board Operations",
            "description": "Update board operation endpoints to enforce role-based access control based on membership roles.",
            "dependencies": ["2.1"],
            "details": "Apply the verifyBoardAccess middleware to all board operation endpoints. Update the updateBoard function to check if user has appropriate permissions (owners can do everything, editors can update content). Modify the deleteBoard function to ensure only owners can delete boards. Update card and list operations to verify that editors have sufficient permissions. Review all board-related endpoints to ensure they properly implement the role-based restrictions.",
            "status": "done",
            "testStrategy": "Test board operations with different user roles to verify correct permissions. Verify owners can perform all operations. Test that editors can create/edit/move cards and lists but not delete boards or modify settings. Ensure non-members cannot access or modify any board data. Test edge cases like attempting to escalate privileges."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement backend invite functionality",
        "description": "Create API endpoints that allow board owners to invite other users by email or username, creating the appropriate BoardMembership records.",
        "status": "done",
        "dependencies": [1, 2],
        "priority": "medium",
        "details": "1. Create a new endpoint `POST /api/boards/{boardId}/invites` that accepts an email/username parameter.\n2. Verify that the requesting user is the board owner.\n3. Look up the target user by email/username.\n4. Create a new BoardMembership record with the target user ID and 'EDITOR' role.\n5. If the user doesn't exist, consider storing a pending invitation that can be claimed later (optional for MVP).\n\nPseudo-code for invite endpoint:\n```\nasync function inviteUser(req, res) {\n  const { boardId } = req.params;\n  const { email } = req.body;\n  const inviterId = req.user.id;\n  \n  // Verify inviter is board owner\n  const membership = await BoardMemberships.findOne({ boardId, userId: inviterId });\n  if (!membership || membership.role !== 'OWNER') {\n    return res.status(403).json({ error: 'Only board owners can invite users' });\n  }\n  \n  // Find user by email\n  const invitee = await Users.findOne({ email });\n  if (!invitee) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  \n  // Create new membership\n  await BoardMemberships.create({\n    boardId,\n    userId: invitee.id,\n    role: 'EDITOR'\n  });\n  \n  // Log activity\n  await Activities.create({\n    boardId,\n    userId: inviterId,\n    action: 'INVITE_USER',\n    details: { inviteeId: invitee.id }\n  });\n  \n  return res.status(200).json({ success: true });\n}\n```",
        "testStrategy": "1. Test successful invite scenarios with valid users.\n2. Test error cases (non-existent users, user already has access, etc.).\n3. Verify proper error messages are returned for each case.\n4. Test that only owners can invite users.\n5. Validate that activity is correctly logged for invites.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement user lookup helper service",
            "description": "Create a service function that can look up users by email or username for the invitation process",
            "dependencies": [],
            "details": "1. Create a new file `userService.js` (or extend existing one if available)\n2. Implement a `findUserByEmailOrUsername` function that accepts either email or username parameter\n3. The function should query the Users collection/table first by email, then by username if no match found\n4. Return the found user object or null if no user exists\n5. Include proper error handling for database issues\n6. Optimize with appropriate database indexes if needed",
            "status": "done",
            "testStrategy": "1. Write unit tests that verify users can be found by email\n2. Write unit tests that verify users can be found by username\n3. Test error cases like invalid inputs or database errors\n4. Test case sensitivity handling"
          },
          {
            "id": 2,
            "title": "Implement board ownership verification function",
            "description": "Create a function that verifies if a user is the owner of a board, to be used in the invite functionality",
            "dependencies": [],
            "details": "1. Create a `verifyBoardOwnership` function in the boardService\n2. Function should accept boardId and userId parameters\n3. Query the BoardMemberships collection to find the user's role for the specified board\n4. Return true if the user has 'OWNER' role, false otherwise\n5. Include proper error handling for cases where board doesn't exist or other DB errors\n6. Implement appropriate caching if performance is a concern",
            "status": "done",
            "testStrategy": "1. Test successful verification for board owners\n2. Test rejection for users with 'EDITOR' role\n3. Test rejection for users with no membership\n4. Test error handling for invalid board IDs"
          },
          {
            "id": 3,
            "title": "Implement board invite API endpoint",
            "description": "Create the REST API endpoint that handles user invitations to boards and creates the appropriate BoardMembership records",
            "dependencies": ["3.1", "3.2"],
            "details": "1. Create a new endpoint handler for `POST /api/boards/{boardId}/invites`\n2. Extract boardId from route parameters and email/username from request body\n3. Use the verifyBoardOwnership function to check if requester is board owner\n4. Return 403 error if requester is not board owner\n5. Use the user lookup service to find target user\n6. If target user isn't found, consider implementing a pending invitation system (optional for MVP) or return a 404 error\n7. Check if user already has membership to this board and return appropriate response\n8. Create new BoardMembership record with 'EDITOR' role\n9. Log the activity using the Activities service\n10. Return success response with the created membership",
            "status": "done",
            "testStrategy": "1. Test successful invitation flow with valid users\n2. Test error cases (non-existent users, users already with access)\n3. Test permission enforcement (non-owners cannot invite)\n4. Verify proper activity logging\n5. Test input validation and error handling"
          }
        ]
      },
      {
        "id": 4,
        "title": "Enhance Activity model for collaborative events",
        "description": "Extend the existing Activity model to track collaboration-related events such as invites, card creation, moves, and comments.",
        "status": "done",
        "dependencies": [1, 2],
        "priority": "medium",
        "details": "1. Review the existing Activity model and extend it to include user information and collaboration-specific action types.\n2. Define new action types: 'INVITE_USER', 'REMOVE_USER', etc.\n3. Ensure all relevant card and list operations update the activity log.\n4. Add appropriate indexes for querying recent activity on a board.\n5. Consider adding a 'visibility' field to potentially filter activities based on importance.\n\nPseudo-code for enhanced Activity model:\n```\ninterface Activity {\n  id: string;\n  boardId: string;\n  userId: string;  // Who performed the action\n  targetUserId?: string;  // For user-related actions like invites\n  action: 'CREATE_CARD' | 'MOVE_CARD' | 'COMMENT' | 'INVITE_USER' | 'REMOVE_USER';\n  details: any;  // JSON object with action-specific details\n  createdAt: Timestamp;\n}\n```\n\nImplementation for logging an activity:\n```\nasync function logActivity(boardId, userId, action, details) {\n  await Activities.create({\n    boardId,\n    userId,\n    action,\n    details,\n    createdAt: new Date()\n  });\n}\n```",
        "testStrategy": "1. Unit test new activity types to ensure they're correctly created.\n2. Verify that all relevant board operations properly log activities.\n3. Test retrieving activities for a specific board.\n4. Validate that activity entries contain all necessary information for UI display.\n5. Performance test to ensure activity logging doesn't impact general application performance.",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create front-end UI for sharing a board",
        "description": "Implement UI elements that allow a board owner to invite other users by entering their email or username.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. Add a 'Share' button in the board header or menu that is only visible to board owners.\n2. Create a modal dialog with an input field for email/username and a submit button.\n3. Implement form validation for valid email format.\n4. Show appropriate success/error messages after invite attempts.\n5. Consider adding a simple animation or visual cue to indicate successful sharing.\n\nPseudo-code for Share component:\n```jsx\nfunction ShareBoardModal({ boardId, isOpen, onClose }) {\n  const [email, setEmail] = useState('');\n  const [status, setStatus] = useState('idle'); // idle, loading, success, error\n  const [errorMessage, setErrorMessage] = useState('');\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setStatus('loading');\n    \n    try {\n      const response = await api.inviteUserToBoard(boardId, email);\n      setStatus('success');\n      setTimeout(() => {\n        onClose();\n        setStatus('idle');\n        setEmail('');\n      }, 2000);\n    } catch (error) {\n      setStatus('error');\n      setErrorMessage(error.message || 'Failed to invite user');\n    }\n  };\n  \n  return (\n    <Modal isOpen={isOpen} onClose={onClose}>\n      <h2>Share Board</h2>\n      <form onSubmit={handleSubmit}>\n        <input \n          type=\"email\" \n          value={email} \n          onChange={(e) => setEmail(e.target.value)}\n          placeholder=\"Enter email address\"\n          required\n        />\n        <button type=\"submit\" disabled={status === 'loading'}>\n          {status === 'loading' ? 'Inviting...' : 'Invite'}\n        </button>\n      </form>\n      {status === 'success' && <p className=\"success\">Invitation sent!</p>}\n      {status === 'error' && <p className=\"error\">{errorMessage}</p>}\n    </Modal>\n  );\n}\n```",
        "testStrategy": "1. Create unit tests for the Share component UI.\n2. Test validation of email input.\n3. Verify UI behavior for all states: initial, loading, success, error.\n4. Test that the share button is only visible to owners.\n5. Conduct usability testing to ensure the sharing flow is intuitive.",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement the collaborator view of shared boards",
        "description": "Update the boards list and board view to show shared boards for collaborators and indicate they are shared.",
        "status": "done",
        "dependencies": [2, 5],
        "priority": "high",
        "details": "1. Modify the boards list API call to include boards where the user is a collaborator.\n2. Update the UI to display shared boards in the user's board list with a visual indicator that they are shared.\n3. Ensure the board view shows appropriate UI elements based on the user's role (e.g., hide delete/share options for editors).\n4. Add a visual indicator in the board header to show that a board is shared.\n\nPseudo-code for updated boards list component:\n```jsx\nfunction BoardsList() {\n  const [boards, setBoards] = useState([]);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    async function fetchBoards() {\n      try {\n        const response = await api.getBoards();\n        setBoards(response.data);\n      } catch (error) {\n        console.error('Failed to fetch boards:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    fetchBoards();\n  }, []);\n  \n  if (loading) return <LoadingSpinner />;\n  \n  return (\n    <div className=\"boards-list\">\n      {boards.map(board => (\n        <BoardCard \n          key={board.id} \n          board={board} \n          isShared={board.membership.role !== 'OWNER'}\n          role={board.membership.role}\n        />\n      ))}\n    </div>\n  );\n}\n\nfunction BoardCard({ board, isShared, role }) {\n  return (\n    <Link to={`/boards/${board.id}`} className=\"board-card\">\n      <h3>{board.title}</h3>\n      {isShared && (\n        <div className=\"shared-indicator\">\n          <ShareIcon /> Shared\n        </div>\n      )}\n    </Link>\n  );\n}\n```",
        "testStrategy": "1. Test that boards list correctly shows both owned and shared boards.\n2. Verify that shared boards are properly indicated in the UI.\n3. Test UI adaptations based on user role (elements visible/hidden appropriately).\n4. Test navigation to shared boards functions correctly.\n5. Validate user permissions are reflected in the UI (e.g., editor can't delete board).",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Develop activity log display in the UI",
        "description": "Create a UI component to display the activity log for a board, focusing on showing activities within card details.",
        "status": "done",
        "dependencies": [4, 6],
        "priority": "medium",
        "details": "1. Design and implement an activity log component that can be displayed in the card detail view.\n2. Create a service to fetch recent activities for a board or card.\n3. Format activity entries to be human-readable (e.g., \"Jane added a comment\" rather than \"USER_COMMENT\").\n4. Implement auto-refresh or polling to keep the activity log current.\n5. Consider adding filtering options for different activity types.\n\nPseudo-code for activity log component:\n```jsx\nfunction ActivityLog({ boardId, cardId }) {\n  const [activities, setActivities] = useState([]);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    async function fetchActivities() {\n      try {\n        const response = await api.getActivities(boardId, cardId);\n        setActivities(response.data);\n      } catch (error) {\n        console.error('Failed to fetch activities:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    fetchActivities();\n    \n    // Poll for updates every 30 seconds\n    const intervalId = setInterval(fetchActivities, 30000);\n    return () => clearInterval(intervalId);\n  }, [boardId, cardId]);\n  \n  function formatActivity(activity) {\n    const user = activity.user.name;\n    \n    switch (activity.action) {\n      case 'CREATE_CARD':\n        return `${user} created this card`;\n      case 'MOVE_CARD':\n        return `${user} moved this card from ${activity.details.fromList} to ${activity.details.toList}`;\n      case 'COMMENT':\n        return `${user} commented: \"${activity.details.comment}\"`;\n      case 'INVITE_USER':\n        return `${user} invited ${activity.details.inviteeName} to this board`;\n      default:\n        return `${user} performed an action`;\n    }\n  }\n  \n  if (loading) return <LoadingSpinner />;\n  \n  return (\n    <div className=\"activity-log\">\n      <h3>Activity</h3>\n      {activities.length === 0 ? (\n        <p>No activity yet</p>\n      ) : (\n        <ul>\n          {activities.map(activity => (\n            <li key={activity.id} className=\"activity-item\">\n              <div className=\"activity-content\">\n                <p>{formatActivity(activity)}</p>\n                <time>{new Date(activity.createdAt).toLocaleString()}</time>\n              </div>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test rendering of the activity log with sample data.\n2. Verify that activities are formatted correctly for different action types.\n3. Test polling/refresh functionality to ensure new activities appear.\n4. Validate date formatting and UI presentation in different browsers.\n5. Test with long activity lists to ensure performance and scrolling behavior.",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement permissions system on the frontend",
        "description": "Update the frontend to respect user roles and permissions, showing or hiding UI elements accordingly.",
        "status": "done",
        "dependencies": [2, 6],
        "priority": "medium",
        "details": "1. Create a permissions utility that can determine if a user can perform specific actions.\n2. Implement a UI context or hook to expose permission checks to components.\n3. Modify UI components to conditionally render based on permissions.\n4. Ensure that only owners can see board deletion and sharing options.\n5. Protect editor actions on the frontend to match backend permissions.\n\nPseudo-code for permissions utility and hook:\n```jsx\n// Permissions utility\nconst Permissions = {\n  canDeleteBoard: (userRole) => userRole === 'OWNER',\n  canInviteUsers: (userRole) => userRole === 'OWNER',\n  canEditCards: (userRole) => userRole === 'OWNER' || userRole === 'EDITOR',\n  canMoveCards: (userRole) => userRole === 'OWNER' || userRole === 'EDITOR',\n  canAddComments: (userRole) => userRole === 'OWNER' || userRole === 'EDITOR',\n};\n\n// Board context with permissions\nconst BoardContext = createContext(null);\n\nfunction BoardProvider({ children, boardId }) {\n  const [board, setBoard] = useState(null);\n  const [userRole, setUserRole] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    async function fetchBoardAndRole() {\n      try {\n        const response = await api.getBoard(boardId);\n        setBoard(response.data.board);\n        setUserRole(response.data.membership.role);\n      } catch (error) {\n        console.error('Failed to fetch board:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    fetchBoardAndRole();\n  }, [boardId]);\n  \n  const can = useCallback((action) => {\n    if (!userRole) return false;\n    return Permissions[action](userRole);\n  }, [userRole]);\n  \n  return (\n    <BoardContext.Provider value={{ board, loading, userRole, can }}>\n      {children}\n    </BoardContext.Provider>\n  );\n}\n\n// Hook to use permissions\nfunction useBoard() {\n  const context = useContext(BoardContext);\n  if (!context) {\n    throw new Error('useBoard must be used within a BoardProvider');\n  }\n  return context;\n}\n```\n\nUsage in a component:\n```jsx\nfunction BoardHeader() {\n  const { board, can } = useBoard();\n  const [shareModalOpen, setShareModalOpen] = useState(false);\n  \n  return (\n    <div className=\"board-header\">\n      <h1>{board.title}</h1>\n      <div className=\"board-actions\">\n        {can('canInviteUsers') && (\n          <button \n            onClick={() => setShareModalOpen(true)}\n            className=\"share-button\"\n          >\n            Share\n          </button>\n        )}\n        {can('canDeleteBoard') && (\n          <button className=\"delete-button\">\n            Delete Board\n          </button>\n        )}\n      </div>\n      \n      {shareModalOpen && (\n        <ShareBoardModal \n          boardId={board.id} \n          isOpen={shareModalOpen} \n          onClose={() => setShareModalOpen(false)} \n        />\n      )}\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Create unit tests for the permissions utility functions.\n2. Test the BoardContext with different user roles.\n3. Verify that UI components correctly show/hide elements based on permissions.\n4. Test boundary conditions (null user, loading state, etc.).\n5. Verify that frontend permissions align with backend permissions for consistency.",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Test and debug collaborative workflows",
        "description": "Perform comprehensive testing of the entire collaborative features set to ensure multiple users can effectively work together on shared boards.",
        "status": "done",
        "dependencies": [5, 6, 7, 8],
        "priority": "high",
        "details": "1. Create test scenarios that cover the full range of collaborative interactions.\n2. Set up test environments with multiple user accounts for realistic testing.\n3. Test concurrent editing of the same board to identify potential race conditions.\n4. Verify that permissions are consistently enforced across all interactions.\n5. Test edge cases like inviting non-existent users, removing collaborators while they're active, etc.\n\nTest scenarios to implement:\n1. Board Owner invites a user who accepts and becomes an Editor\n2. Two users simultaneously edit different cards on the same board\n3. Two users simultaneously edit the same card (potential conflict)\n4. An Editor attempts to perform Owner-only actions (both UI and direct API calls)\n5. Owner removes an Editor while they are actively using the board\n6. Test activity log updates when multiple users are active\n\nPseudo-code for a test helper:\n```javascript\nasync function simulateMultiUserWorkflow() {\n  // Create test users\n  const owner = await TestHelper.createUser('owner@test.com');\n  const editor = await TestHelper.createUser('editor@test.com');\n  \n  // Owner creates a board\n  const board = await TestHelper.createBoard(owner, 'Test Collaborative Board');\n  \n  // Owner invites editor\n  await TestHelper.inviteUserToBoard(owner, board.id, editor.email);\n  \n  // Verify editor can see the board\n  const editorBoards = await TestHelper.getUserBoards(editor);\n  assert(editorBoards.some(b => b.id === board.id));\n  \n  // Editor creates a card\n  const list = board.lists[0];\n  const card = await TestHelper.createCard(editor, board.id, list.id, 'Test Card');\n  \n  // Owner modifies the card\n  await TestHelper.updateCard(owner, card.id, { title: 'Updated Title' });\n  \n  // Verify both users see the updated card\n  const ownerView = await TestHelper.getBoard(owner, board.id);\n  const editorView = await TestHelper.getBoard(editor, board.id);\n  \n  const ownerCard = ownerView.lists[0].cards.find(c => c.id === card.id);\n  const editorCard = editorView.lists[0].cards.find(c => c.id === card.id);\n  \n  assert(ownerCard.title === 'Updated Title');\n  assert(editorCard.title === 'Updated Title');\n  \n  // Verify activity log shows both users' actions\n  const activities = await TestHelper.getBoardActivities(board.id);\n  assert(activities.some(a => a.userId === editor.id && a.action === 'CREATE_CARD'));\n  assert(activities.some(a => a.userId === owner.id && a.action === 'UPDATE_CARD'));\n}\n```",
        "testStrategy": "1. Create automated test scripts for each collaborative workflow.\n2. Perform manual testing with real users in a staging environment.\n3. Use browser automation tools to simulate multiple users interacting concurrently.\n4. Test under various network conditions (e.g., slow connections, intermittent connectivity).\n5. Validate that error handling works properly in collaborative contexts.",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Documentation and deployment preparation",
        "description": "Create comprehensive documentation for the shared boards feature and prepare for deployment to production.",
        "status": "done",
        "dependencies": [9],
        "priority": "low",
        "details": "1. Document the database schema changes and new API endpoints.\n2. Create user-facing documentation on how to use shared boards.\n3. Update deployment scripts to handle the new models and relationships.\n4. Create a rollback plan in case issues arise in production.\n5. Document known limitations and future improvement areas.\n\nDocumentation to create:\n1. Technical documentation:\n   - Database schema diagram showing relationships\n   - API endpoint documentation with request/response examples\n   - Permissions matrix showing roles and allowed actions\n\n2. User documentation:\n   - How to share a board (owner perspective)\n   - How to access and work with shared boards (editor perspective)\n   - Activity log features and interpretation\n\n3. Deployment documentation:\n   - Required environment variables\n   - Migration steps for existing data\n   - Monitoring guidelines for the new features\n\nPseudo-code for deployment script update:\n```bash\n#!/bin/bash\n\n# Backup existing database\nfirebase firestore:backup --project=driftboard\n\n# Deploy Firebase Security Rules update\nfirebase deploy --only firestore:rules\n\n# Deploy updated Firebase Functions\nfirebase deploy --only functions\n\n# Deploy frontend with new features\nvercel deploy --prod\n\n# Run post-deployment verification\nnode scripts/verify-deployment.js\n\necho \"Deployment complete. Monitoring dashboard: https://vercel.com/driftboard/dashboard\"\n```",
        "testStrategy": "1. Review documentation for accuracy and completeness.\n2. Have someone unfamiliar with the feature attempt to use it based solely on the documentation.\n3. Test deployment process in a staging environment before production.\n4. Verify rollback procedure works as expected.\n5. Create a post-deployment monitoring plan to catch any issues quickly.",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-18T03:22:18.454Z",
      "updated": "2025-12-18T18:32:19.966Z",
      "description": "Tasks for shared-boards context"
    }
  },
  "infrastructure": {
    "tasks": [
      {
        "id": 84,
        "title": "Implement Pre-commit Hooks",
        "description": "Setup Husky for pre-commit hooks to run tests and linting",
        "details": "Install Husky and configure pre-commit hooks to prevent commits with failing tests.",
        "testStrategy": "Verify that hooks prevent commits with test failures",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "tag": "infrastructure",
        "metadata": {
          "moveHistory": [
            {
              "fromTag": "master",
              "toTag": "infrastructure",
              "timestamp": "2026-01-10T17:24:44.407Z"
            }
          ]
        }
      },
      {
        "id": 85,
        "title": "Setup CI/CD Integration",
        "description": "Configure GitHub Actions for automated test execution",
        "details": "Create a GitHub Actions workflow to run tests on PRs and merges. Include coverage reporting.",
        "testStrategy": "Verify that CI/CD pipeline runs tests successfully",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "tag": "infrastructure",
        "metadata": {
          "moveHistory": [
            {
              "fromTag": "master",
              "toTag": "infrastructure",
              "timestamp": "2026-01-10T17:24:44.407Z"
            }
          ]
        }
      },
      {
        "id": 86,
        "title": "Configure Quality Gates",
        "description": "Block merges on test failures and ensure coverage thresholds",
        "details": "Implement quality gates in the CI/CD pipeline to enforce test success and coverage targets.",
        "testStrategy": "Verify that merges are blocked on test failures",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "tag": "infrastructure",
        "metadata": {
          "moveHistory": [
            {
              "fromTag": "master",
              "toTag": "infrastructure",
              "timestamp": "2026-01-10T17:24:44.407Z"
            }
          ]
        }
      },
      {
        "id": 87,
        "title": "Research Firebase Infrastructure as Code and Deployment Pipeline Integration",
        "description": "Investigate and document best practices for implementing Infrastructure as Code for Firebase resources and how to integrate these practices into our existing deployment pipeline.",
        "details": "1. Research IAC tools compatible with Firebase (Firebase CLI, Terraform, Pulumi, etc.)\n2. Compare the features, benefits, and limitations of each tool\n3. Document how to define Firebase resources (Firestore, Functions, Hosting, etc.) as code\n4. Investigate how to integrate the chosen IAC approach with our existing GitHub Actions CI/CD pipeline\n5. Research versioning strategies for Firebase infrastructure\n6. Explore testing strategies for Firebase infrastructure\n7. Document the recommended approach with example configurations\n8. Consider security best practices for Firebase IAC\n9. Analyze cost implications of different approaches\n10. Evaluate implementation complexity and required team knowledge",
        "testStrategy": "1. Create a proof-of-concept implementation using the recommended IAC tool\n2. Verify that Firebase resources can be provisioned successfully using the IAC configuration\n3. Test the integration with the existing CI/CD pipeline\n4. Validate that the approach supports different environments (dev, staging, production)\n5. Ensure the solution allows for easy rollbacks if necessary\n6. Document any limitations or potential issues discovered during testing",
        "status": "pending",
        "dependencies": [85],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-01-10T17:08:21.441Z",
      "updated": "2026-01-10T20:11:47.187Z",
      "description": "Tag created on 1/10/2026"
    }
  },
  "separation": {
    "tasks": [
      {
        "id": 1,
        "title": "Research and Plan Architecture for Driftboard Front-end/Back-end Separation",
        "description": "Investigate and document a strategy for breaking Driftboard into separate front-end and back-end components, with consideration for microservices or other appropriate architectural patterns that would support multiple front-end interfaces.",
        "details": "1. Analyze the current Driftboard architecture to identify clear separation points between data/business logic and presentation layers.\n\n2. Research and evaluate architectural patterns suitable for this separation:\n   - Traditional client-server architecture\n   - Microservices architecture\n   - API Gateway pattern\n   - Backend for Frontend (BFF) pattern\n   - Event-driven architecture\n\n3. Design a high-level architecture diagram showing:\n   - Core back-end services/components\n   - API layers and interface contracts\n   - Front-end application structure for different clients (web boards, web notes, CLI, etc.)\n   - Authentication and authorization flow across components\n   - Data persistence strategy\n\n4. Consider technical implications including:\n   - State management across distributed components\n   - Deployment strategy (containerization, orchestration)\n   - Development workflow changes needed\n   - Performance considerations with distributed architecture\n   - Cross-cutting concerns (logging, monitoring, error handling)\n\n5. Document migration strategy from current architecture to proposed architecture, including phasing recommendations and potential risks.\n\n6. Create a proof-of-concept design for one specific feature to demonstrate the architecture's viability.",
        "testStrategy": "1. Peer review of architectural documentation with stakeholders to validate requirements are met\n\n2. Create evaluation matrix comparing different architectural approaches against key criteria:\n   - Scalability\n   - Maintainability\n   - Development velocity\n   - Technology alignment\n   - Implementation complexity\n\n3. Prototype a minimal implementation of the proposed architecture using one representative feature (like board creation) that exercises both front-end and back-end components\n\n4. Conduct load testing on the prototype to validate performance assumptions\n\n5. Document potential failure modes and mitigation strategies for the proposed architecture\n\n6. Present findings to the development team for feedback and validation of technical approach",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze current Driftboard architecture and identify separation points",
            "description": "Conduct a thorough analysis of the existing Driftboard codebase to identify clear separation points between data/business logic and presentation layers. Document current dependencies, data flows, and component interactions to establish a foundation for architectural decisions.",
            "dependencies": [],
            "details": "Review the entire Driftboard codebase to map out current architecture. Identify all front-end components (UI, presentation logic) and back-end components (data access, business logic, APIs). Document tight couplings and dependencies that would need to be addressed during separation. Create an inventory of shared state, common utilities, and cross-cutting concerns. This analysis will serve as the foundation for all subsequent architectural decisions and should include code complexity metrics and dependency graphs.",
            "status": "pending",
            "testStrategy": "Peer review of analysis documentation with senior developers to ensure completeness and accuracy.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Research and evaluate suitable architectural patterns",
            "description": "Research and evaluate architectural patterns suitable for front-end/back-end separation including traditional client-server, microservices, API Gateway, BFF, and event-driven architectures. Create evaluation criteria and comparison matrix based on Driftboard's specific requirements.",
            "dependencies": [1],
            "details": "Based on the current architecture analysis, evaluate each pattern's suitability for Driftboard's specific needs. Consider factors like scalability requirements, team structure, deployment constraints, and support for multiple front-end interfaces (web boards, web notes, CLI). Create a detailed comparison matrix scoring each pattern against key criteria: scalability, maintainability, development velocity, technology alignment, and implementation complexity. Document pros and cons of each approach specifically for Driftboard's use case, including estimated costs and team skill requirements.",
            "status": "pending",
            "testStrategy": "Present findings to technical stakeholders for validation and gather feedback on recommended approaches.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Design high-level architecture and address technical implications",
            "description": "Create comprehensive architecture diagrams showing core back-end services, API layers, front-end application structures, authentication flows, and data persistence strategy. Address state management, deployment, workflow, performance, and cross-cutting concerns.",
            "dependencies": [1, 2],
            "details": "Develop detailed architecture diagrams using standard notation (C4 model or similar). Define core back-end services/components with clear boundaries and responsibilities. Design API layers and interface contracts (REST, GraphQL, or gRPC). Map out front-end application structure for different clients (web boards, web notes, CLI). Design authentication and authorization flow using OAuth 2.0 or JWT tokens. Define data persistence strategy and database schema evolution plan. Address technical implications: distributed state management solutions (Redis, etc.), containerization strategy (Docker), orchestration (Kubernetes or Vercel), CI/CD pipeline changes, performance optimization strategies (caching, CDN), and cross-cutting concerns (centralized logging with ELK, monitoring with Prometheus/Grafana, error tracking with Sentry).",
            "status": "pending",
            "testStrategy": "Architecture review board meeting with all stakeholders to validate design decisions and identify potential issues.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Document migration strategy and risk assessment",
            "description": "Create a detailed migration strategy from current architecture to proposed architecture including phasing recommendations, timeline, resource requirements, and comprehensive risk assessment with mitigation plans.",
            "dependencies": [1, 2, 3],
            "details": "Develop a phased migration plan with clear milestones and deliverables. Define Phase 1: API extraction and dual-running mode. Phase 2: Front-end separation and independent deployment. Phase 3: Microservices decomposition (if applicable). Phase 4: Full cutover and deprecation of monolith. Create detailed timeline with resource allocation estimates. Conduct comprehensive risk assessment covering technical risks (data consistency, downtime), organizational risks (team learning curve, productivity dip), and business risks (feature delivery slowdown). For each risk, define specific mitigation strategies and contingency plans. Include rollback procedures for each phase. Define success metrics and go/no-go criteria for each phase gate.",
            "status": "pending",
            "testStrategy": "Review migration plan with project management and DevOps teams to validate feasibility and resource estimates.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create proof-of-concept for critical architecture component",
            "description": "Build a proof-of-concept implementation for one specific feature to demonstrate the viability of the proposed architecture. This should validate key technical decisions and identify potential implementation challenges before full-scale development.",
            "dependencies": [1, 2, 3, 4],
            "details": "Select a representative feature from Driftboard (e.g., board creation or note synchronization) that exercises critical architecture components. Implement a minimal version using the proposed architecture: separate front-end application (React or Vue), back-end API service (Node.js/Express or similar), authentication flow, and database interaction. Set up local development environment with Docker Compose to simulate distributed deployment. Configure API Gateway or BFF pattern if selected in architecture. Implement end-to-end functionality including error handling and logging. Document lessons learned, performance observations, and any deviations from the original architecture design. This PoC will serve as a reference implementation for the full migration and should include automated tests.",
            "status": "pending",
            "testStrategy": "Functional testing of the PoC feature, performance benchmarking against current implementation, and team demo to gather feedback.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 2,
        "title": "Investigate Mono-repo Structure and Vercel Deployment Compatibility",
        "description": "Research and document mono-repo management strategies, tools, and configurations that align with Vercel's deployment platform and the planned front-end/back-end architecture.",
        "details": "1. Research mono-repo management tools and frameworks:\n   - Turborepo (Vercel's native solution)\n   - Nx (comprehensive mono-repo tooling)\n   - Lerna (JavaScript-focused)\n   - Rush (Microsoft's scalable solution)\n   - pnpm workspaces (lightweight approach)\n\n2. Analyze Vercel's mono-repo capabilities and constraints:\n   - Multiple project deployment from single repository\n   - Build configuration and caching strategies\n   - Environment variable management across projects\n   - Deployment previews for different apps/services\n   - Root directory configuration options\n   - Build time limitations and optimization techniques\n\n3. Evaluate architectural alignment with Task #1 findings:\n   - Map proposed front-end/back-end separation to mono-repo structure\n   - Define package/app boundaries (e.g., web app, API services, shared libraries)\n   - Determine if back-end services can/should be deployed to Vercel or external platforms\n   - Assess Serverless Functions vs. external API hosting implications\n\n4. Design mono-repo directory structure:\n   - Propose folder hierarchy (apps/, packages/, services/)\n   - Define code sharing strategies (shared components, utilities, types)\n   - Establish naming conventions and boundaries\n   - Consider migration path from current structure\n\n5. Investigate CI/CD and development workflow:\n   - Local development setup and tooling\n   - Build pipeline optimization and caching\n   - Affected/changed-based testing and deployment\n   - Versioning strategies (independent vs. fixed)\n\n6. Analyze cost and performance implications:\n   - Vercel pricing for multiple projects\n   - Build minute consumption optimization\n   - Dependency installation caching benefits\n   - Deployment frequency impact\n\n7. Document security considerations:\n   - Access control across packages\n   - Secret management for multiple environments\n   - Code sharing boundaries and permissions\n\n8. Create decision matrix comparing mono-repo vs. poly-repo approaches based on:\n   - Team size and collaboration needs\n   - Code reuse requirements\n   - Deployment complexity\n   - Tooling maturity and learning curve\n   - Long-term maintainability",
        "testStrategy": "1. **Proof of Concept Implementation:**\n   - Set up a minimal mono-repo structure using top 2 recommended tools\n   - Create sample applications representing front-end and back-end components\n   - Configure Vercel deployment for multiple projects from the same repository\n   - Test build caching and incremental builds\n\n2. **Deployment Testing:**\n   - Deploy front-end application to Vercel with proper routing\n   - Deploy Serverless Functions as API endpoints if applicable\n   - Test preview deployments for feature branches\n   - Verify environment-specific configurations work correctly\n   - Measure cold start times and overall performance\n\n3. **Workflow Validation:**\n   - Simulate parallel development on multiple packages\n   - Test local development experience (hot reloading, dependency linking)\n   - Run affected-only builds and tests\n   - Verify code sharing between packages works seamlessly\n\n4. **Performance Benchmarking:**\n   - Measure build times for full repo vs. incremental builds\n   - Compare install times with and without caching\n   - Analyze deployment times across different project sizes\n   - Document resource usage (memory, CPU) during builds\n\n5. **Documentation Review:**\n   - Peer review of mono-repo strategy document\n   - Validate that setup instructions are clear and reproducible\n   - Review decision matrix with stakeholders\n   - Ensure migration plan is feasible and well-documented\n\n6. **Stakeholder Validation:**\n   - Present findings to development team for feedback\n   - Review Vercel cost implications with finance/product stakeholders\n   - Demo the proof of concept to technical leadership\n   - Gather feedback on tooling choice and structure",
        "status": "pending",
        "dependencies": ["1"],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Research and evaluate mono-repo management tools",
            "description": "Evaluate Turborepo, Nx, Lerna, Rush, and pnpm workspaces against project requirements, Vercel compatibility, and team expertise.",
            "dependencies": [],
            "details": "Conduct in-depth analysis of each tool's features, performance, caching capabilities, community support, and integration with Vercel. Create comparison matrix scoring each tool on scalability, learning curve, build optimization, and cost-effectiveness. Document pros/cons specific to Driftboard's front-end/back-end architecture needs.",
            "status": "pending",
            "testStrategy": "Create proof-of-concept setups for top 2 tools and measure build times, cache efficiency, and developer experience.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Analyze Vercel's mono-repo deployment capabilities",
            "description": "Document Vercel's constraints and features for multi-project deployments, including build configs, caching, and environment management.",
            "dependencies": [1],
            "details": "Investigate Vercel's root directory configuration, build limits, deployment previews, and Serverless Functions integration. Test environment variable scoping across projects. Document build minute optimization techniques and analyze pricing implications for multiple concurrent deployments. Identify workarounds for potential limitations.",
            "status": "pending",
            "testStrategy": "Deploy sample projects from test mono-repo to validate configuration options and measure actual build performance.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Design mono-repo architecture and directory structure",
            "description": "Create detailed folder hierarchy mapping front-end, back-end, and shared packages with clear boundaries and naming conventions.",
            "dependencies": [1, 2],
            "details": "Propose concrete structure (apps/web, apps/admin, apps/api, packages/shared, packages/types, etc.). Define code sharing strategies for components, utilities, and TypeScript types. Map Task #1's architecture to mono-repo packages. Consider migration path from current structure. Establish package dependency rules and boundaries to prevent circular dependencies.",
            "status": "pending",
            "testStrategy": "Validate structure by creating mock packages and verifying import paths, build isolation, and dependency graph correctness.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop CI/CD workflow and development strategy",
            "description": "Define local development setup, build pipeline optimization, caching strategies, and affected-based testing/deployment workflows.",
            "dependencies": [3],
            "details": "Configure Turborepo/Nx pipelines for optimal caching. Set up affected/changed detection for testing and deployment. Define local development workflow with hot-reloading across packages. Establish versioning strategy (independent vs fixed). Document developer onboarding process. Create GitHub Actions workflows for CI that leverage mono-repo tooling.",
            "status": "pending",
            "testStrategy": "Simulate developer workflow with multiple concurrent changes and verify affected detection accuracy and cache hit rates.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create decision matrix and final recommendation",
            "description": "Compile cost analysis, security considerations, and comprehensive comparison matrix to make final mono-repo vs poly-repo recommendation.",
            "dependencies": [1, 2, 3, 4],
            "details": "Analyze Vercel pricing for multi-project setup, calculate build minute costs, and assess performance implications. Document security model for access control and secret management. Create final decision matrix comparing mono-repo vs poly-repo across team collaboration, code reuse, deployment complexity, and maintainability. Present actionable recommendation with migration plan and risk mitigation strategies.",
            "status": "pending",
            "testStrategy": "Peer review decision matrix with stakeholders and validate recommendation against project constraints and budget.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 3,
        "title": "Design and Implement Separate Admin Dashboard with Usage Statistics",
        "description": "Design and implement a separate admin dashboard application that provides statistical insights into Driftboard usage, including user counts, board metrics, and database statistics. The dashboard should be deployed independently from the main web application and leverage existing dashboard/reporting frameworks.",
        "details": "**Architecture & Technology Stack:**\n1. **Application Separation**: Create a standalone admin dashboard application that runs on a separate domain/subdomain (e.g., admin.driftboard.com) or local Docker deployment. This should NOT be integrated into the main Driftboard web-app codebase.\n\n2. **Framework Selection**: Evaluate and select a lightweight dashboard/reporting framework:\n   - **Metabase** (recommended): Open-source BI tool, easy setup, good PostgreSQL support\n   - **Apache Superset**: More feature-rich but heavier\n   - **Grafana**: Primarily for metrics/monitoring but can be adapted\n   - **Custom React Dashboard**: Using Recharts, Chart.js, or similar (fallback option)\n\n3. **Data Access Strategy**: \n   - Create read-only database views for admin statistics to ensure security\n   - Implement a dedicated read replica connection if database load is a concern\n   - Use a thin API layer if custom dashboard is chosen (Node.js/Express or similar)\n\n4. **Authentication & Authorization**:\n   - Implement admin user category/role in the main Driftboard system\n   - Use JWT or session-based auth with secure cookie sharing between domains\n   - Add IP whitelisting for additional security if hosted locally\n\n**Implementation Steps:**\n1. Set up new repository or mono-repo package for admin dashboard\n2. Configure Docker containerization for isolated deployment\n3. Create database views for the following metrics:\n   - `admin_users_stats`: Total users, new users by time period, active users\n   - `admin_boards_stats`: Total boards, boards created by period, boards per user\n   - `admin_changes_stats`: Changes in last hour/day/week/month (from audit log)\n   - `admin_db_stats`: Table sizes, index usage, connection counts\n4. Implement dashboard pages:\n   - Overview page with KPI cards (total users, boards, changes)\n   - Users analytics page with charts and filters\n   - Boards analytics page with growth trends\n   - Database health page with performance metrics\n5. Add time-range selectors (last hour, day, week, month) for all relevant charts\n6. Configure automated refresh intervals for real-time insights\n7. Set up logging and monitoring for the dashboard itself\n\n**Security Considerations:**\n- All database connections must use read-only credentials\n- Implement rate limiting on API endpoints\n- Use HTTPS only, with HSTS enabled\n- Regular security updates for chosen framework\n- Audit logging of admin dashboard access",
        "testStrategy": "**Functional Testing:**\n1. **Metrics Accuracy Tests:**\n   - Seed test database with known quantities of users, boards, and changes\n   - Verify dashboard displays exact counts matching database queries\n   - Test time-range filters (hour/day/week/month) return correct data subsets\n   - Compare dashboard statistics against direct database queries\n\n2. **Dashboard UI Tests:**\n   - Verify all charts render without errors across different time ranges\n   - Test responsive design on desktop, tablet, and mobile viewports\n   - Validate interactive elements (filters, date pickers, refresh buttons) work correctly\n   - Check that data refresh intervals update displays as expected\n\n3. **Authentication & Authorization Tests:**\n   - Attempt access without authentication - should redirect to login\n   - Test with non-admin user credentials - should receive 403 Forbidden\n   - Verify session timeout and re-authentication flow\n   - Test concurrent admin sessions from multiple devices\n\n**Performance Testing:**\n1. **Load Testing:**\n   - Simulate 10+ concurrent admin users accessing dashboard simultaneously\n   - Measure page load times for each dashboard section\n   - Verify database query performance with large datasets (100k+ users/boards)\n   - Test caching effectiveness for repeated queries\n\n2. **Database Impact Assessment:**\n   - Monitor database CPU/memory usage during dashboard queries\n   - Verify read replica lag doesn't affect data freshness\n   - Test connection pool efficiency\n\n**Security Testing:**\n1. **Penetration Testing:**\n   - Attempt SQL injection via dashboard filters\n   - Test for XSS vulnerabilities in chart labels and data points\n   - Verify no sensitive user data is exposed in admin views\n   - Check for information leakage in error messages\n\n2. **Access Control Testing:**\n   - Attempt to bypass authentication via direct URL access\n   - Test CSRF protection on all state-changing operations\n   - Verify IP whitelisting (if implemented) blocks unauthorized IPs\n\n**Deployment Testing:**\n1. **Docker Deployment Test:**\n   - Build and run Docker container locally\n   - Verify all environment variables are properly configured\n   - Test container restart and health check endpoints\n   - Validate network isolation from main application\n\n2. **Integration Testing:**\n   - Deploy to staging environment with production-like data\n   - Test cross-domain cookie authentication (if applicable)\n   - Verify SSL certificate installation and HTTPS redirection\n   - Monitor error logging and alerting setup",
        "status": "cancelled",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Evaluate and Select Dashboard Framework with Repository Setup",
            "description": "Evaluate Metabase, Apache Superset, Grafana, and custom React dashboard options against project requirements. Select optimal framework and initialize standalone repository or mono-repo package structure with proper configuration files and documentation.",
            "dependencies": [],
            "details": "Conduct technical evaluation of each framework considering ease of setup, PostgreSQL compatibility, resource requirements, and maintenance overhead. Document pros/cons analysis. For Metabase (recommended), set up Docker-based deployment configuration. Initialize Git repository with .gitignore, README with setup instructions, and environment template files. Configure build pipeline and dependency management.",
            "status": "pending",
            "testStrategy": "Perform proof-of-concept deployment with sample data source to verify framework connectivity and basic functionality. Validate Docker container builds successfully and web interface is accessible.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Secure Read-Only Database Views for Statistics",
            "description": "Create PostgreSQL read-only database views for admin statistics including user metrics, board analytics, change logs, and database health indicators to ensure secure data access without exposing underlying tables.",
            "dependencies": [1],
            "details": "Implement SQL views: admin_users_stats (total users, new users by period, active users), admin_boards_stats (total boards, creation trends, boards per user), admin_changes_stats (changes by time period from audit log), and admin_db_stats (table sizes, index usage, connection counts). Configure read-only database role with minimal privileges. Document view schemas and refresh policies. Set up read replica connection pooling if needed.",
            "status": "pending",
            "testStrategy": "Unit test each view with seeded test data to verify accurate aggregation. Run integration tests comparing view results against direct queries. Test read-only role cannot modify data.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Admin Authentication and Authorization System",
            "description": "Implement admin user role management in the main Driftboard system and configure secure authentication flow between the main application and admin dashboard using JWT tokens or session-based auth with cross-domain cookie support.",
            "dependencies": [1],
            "details": "Add 'admin' role to user table in main application. Implement JWT generation endpoint with short expiration and refresh token mechanism. Configure secure, HTTPOnly cookies with SameSite=None and Secure attributes for cross-subdomain authentication. Add IP whitelisting middleware for admin dashboard access. Create login/logout flows and session validation endpoints. Document security configuration.",
            "status": "pending",
            "testStrategy": "Test authentication flow: login, token generation, access to protected routes, logout. Verify non-admin users cannot access dashboard. Test IP whitelisting blocks unauthorized IPs. Validate cookie security attributes.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build Dashboard Pages and Configure Deployment",
            "description": "Build dashboard interface with four core pages: Overview KPI cards, Users Analytics with charts, Boards Analytics with growth trends, and Database Health monitoring. Configure Docker deployment, time-range selectors, and auto-refresh functionality.",
            "dependencies": [2, 3],
            "details": "Implement Overview page with KPI cards showing total users, boards, and changes. Create Users Analytics page with line charts for growth and bar charts for activity. Build Boards Analytics page with creation trends and distribution metrics. Develop Database Health page with performance indicators. Add universal time-range selectors (hour/day/week/month) and configure 5-minute auto-refresh intervals. Set up Docker multi-stage build for production deployment.",
            "status": "pending",
            "testStrategy": "Functional testing: verify all charts render correctly with real data, time-range filters return accurate subsets, auto-refresh updates data. Perform UI interaction tests. Validate Docker image builds and runs successfully.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Apply Security Hardening and Monitoring",
            "description": "Apply final security layer with read-only database credentials, rate limiting on all API endpoints, HTTPS enforcement with HSTS, comprehensive audit logging for admin access, and monitoring setup for dashboard health and performance.",
            "dependencies": [4],
            "details": "Configure dedicated read-only database user for dashboard connections. Implement rate limiting (60 requests/minute per IP) on API endpoints. Enable HTTPS with TLS 1.2+ and configure HSTS headers. Add audit logging table to track all admin dashboard access including user ID, IP, timestamp, and actions. Set up Prometheus metrics collection and Grafana alerts for dashboard performance, error rates, and availability.",
            "status": "pending",
            "testStrategy": "Conduct security penetration testing: verify read-only credentials cannot write, rate limiting blocks excessive requests, HTTPS is enforced. Verify audit logs capture all access. Test monitoring alerts trigger on simulated failures.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-18T15:20:31.545Z"
      },
      {
        "id": 4,
        "title": "Docker Infrastructure & Metabase Containerization",
        "description": "Create Docker containerization setup for Metabase with isolated networking, persistent volumes, and environment-based configuration. Configure localhost-only access and resource limits suitable for local development.",
        "details": "Create a docker-compose.yml file with the following specification:\n\n```yaml\nversion: '3.8'\nservices:\n  metabase:\n    image: metabase/metabase:latest\n    container_name: driftboard-admin-dashboard\n    ports:\n      - \"127.0.0.1:3000:3000\"  # Bind to localhost only\n    environment:\n      MB_DB_TYPE: postgres\n      MB_DB_DBNAME: metabase\n      MB_DB_PORT: 5432\n      MB_DB_USER: metabase\n      MB_DB_PASS: ${METABASE_DB_PASSWORD}\n      MB_DB_HOST: postgres\n      MB_PASSWORD: ${METABASE_ADMIN_PASSWORD}\n      MB_ALLOW_ANONYMOUS: \"false\"\n      MB_SITE_NAME: \"Driftboard Admin Dashboard\"\n    volumes:\n      - metabase-data:/metabase-data\n    depends_on:\n      - postgres\n    restart: unless-stopped\n    mem_limit: 2g\n    \n  postgres:\n    image: postgres:15-alpine\n    container_name: metabase-db\n    environment:\n      POSTGRES_DB: metabase\n      POSTGRES_USER: metabase\n      POSTGRES_PASSWORD: ${METABASE_DB_PASSWORD}\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    restart: unless-stopped\n\nvolumes:\n  metabase-data:\n  postgres-data:\n```\n\nCreate a .env.template file with placeholder values. Add a startup script that waits for Metabase to be healthy before proceeding.",
        "testStrategy": "Verify container starts with 'docker-compose up -d' and is accessible only at http://localhost:3000. Check that external network access is blocked using 'curl -I http://[external-ip]:3000' from another machine. Validate volume persistence by restarting container and checking data retention.",
        "priority": "high",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-21T00:46:09.257Z"
      },
      {
        "id": 5,
        "title": "Firestore Connector Configuration & Secure Credentials",
        "description": "Configure Metabase Firestore connector with read-only Firebase service account credentials. Set up secure credential management through Docker secrets and validate connection to Firestore collections.",
        "details": "Implementation steps:\n\n1. Create Firebase service account with 'Firebase Read-Only Viewer' role:\n   - Go to Firebase Console > Project Settings > Service Accounts\n   - Generate new private key\n   - Save as firebase-service-account.json\n\n2. Create Docker secret configuration in docker-compose.yml:\n```yaml\nsecrets:\n  firebase_credentials:\n    file: ./secrets/firebase-service-account.json\n```\n\n3. Mount secret in metabase service:\n```yaml\nservices:\n  metabase:\n    secrets:\n      - firebase_credentials\n    environment:\n      MB_FIREBASE_SERVICE_ACCOUNT: /run/secrets/firebase_credentials\n```\n\n4. In Metabase Admin Panel, add Firestore database:\n   - Database type: Firestore\n   - Project ID: ${FIREBASE_PROJECT_ID}\n   - Service Account JSON: /run/secrets/firebase_credentials\n   - Use JDBC connection string: jdbc:firestore://[PROJECT_ID].firebaseio.com;AuthFile=/run/secrets/firebase_credentials\n\n5. Set read-only permissions at Firebase IAM level to enforce security.",
        "testStrategy": "Test connection in Metabase admin panel. Verify read-only access by attempting a write operation (should fail). Run a simple COUNT query on users collection and compare with Firestore console. Check Docker logs for credential loading errors. Validate that service account file is not accessible from Metabase UI.",
        "priority": "high",
        "dependencies": ["4"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-20T21:14:46.573Z"
      },
      {
        "id": 6,
        "title": "Core KPI Metrics Dashboard Creation",
        "description": "Build Metabase native queries for all core KPIs and assemble into a main dashboard. Implement Firestore-specific query syntax for counting entities and calculating aggregations.",
        "details": "Create Metabase questions using native Firestore SQL syntax:\n\n```sql\n-- Question 1: Total Users\nSELECT COUNT(*) as total_users FROM `users`;\n\n-- Question 2: Active Users (active = logged in within last 30 days)\nSELECT COUNT(*) as active_users \nFROM `users` \nWHERE lastLoginAt >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY);\n\n-- Question 3: Total Boards\nSELECT COUNT(*) as total_boards FROM `boards`;\n\n-- Question 4: Boards per User Distribution\nSELECT ownerId, COUNT(*) as board_count \nFROM `boards` \nGROUP BY ownerId;\n\n-- Question 5: Shared Boards Count\nSELECT COUNT(*) as shared_boards \nFROM `boards` \nWHERE sharedWith IS NOT NULL AND ARRAY_LENGTH(sharedWith) > 0;\n\n-- Question 6: Total Lists\nSELECT COUNT(*) as total_lists FROM `lists`;\n\n-- Question 7: Total Cards\nSELECT COUNT(*) as total_cards FROM `cards`;\n\n-- Question 8: Total Comments\nSELECT COUNT(*) as total_comments FROM `comments`;\n```\n\nCreate main dashboard 'Driftboard KPI Overview' with these questions arranged in a 2x4 grid. Set refresh rate to 'Never' for manual control. Add text cards with entity definitions.",
        "testStrategy": "Execute each query and verify results match Firestore console counts. Test with known test data: create 1 user, 1 board, 2 lists, 3 cards, 1 comment and verify dashboard shows exact counts. Check query performance on production-sized collections using EXPLAIN. Validate dashboard loads in under 3 seconds.",
        "priority": "high",
        "dependencies": ["5"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-21T00:26:50.905Z"
      },
      {
        "id": 7,
        "title": "Drill-Down Navigation & Entity-Specific Dashboards",
        "description": "Implement click-through navigation from aggregate metrics to entity-specific detail views. Configure Metabase dashboard parameters and custom destinations for user and board drill-down paths.",
        "details": "Configure drill-down behavior in Metabase:\n\n1. For User Count metric:\n   - Set click behavior: 'Go to custom destination'\n   - Destination: Dashboard 'User Details' with parameter userId\n   - Pass clicked userId as filter\n\n2. Create 'User Details' dashboard with questions:\n```sql\n-- User Recent Activity\nSELECT * FROM `activities` \nWHERE userId = {{userId}} \nORDER BY timestamp DESC \nLIMIT 50;\n\n-- User Boards\nSELECT * FROM `boards` \nWHERE ownerId = {{userId}};\n```\n\n3. For Shared Boards metric:\n   - Set click behavior to 'Board Details' dashboard\n   - Pass boardId parameter\n\n4. Create 'Board Details' dashboard:\n```sql\n-- Board Participants\nSELECT sharedWith FROM `boards` \nWHERE boardId = {{boardId}};\n\n-- Board Lists & Cards Count\nSELECT l.boardId, COUNT(DISTINCT l.listId) as list_count, \n       COUNT(c.cardId) as card_count\nFROM `lists` l\nLEFT JOIN `cards` c ON l.listId = c.listId\nWHERE l.boardId = {{boardId}}\nGROUP BY l.boardId;\n```\n\n5. Enable 'Fullscreen' and 'Auto-refresh' UI elements for manual control.",
        "testStrategy": "Click each metric on main dashboard and verify navigation to correct detail view. Test parameter passing by clicking on specific user/board IDs. Verify back-navigation works. Validate that detail dashboards show correct filtered data. Test with multiple browser tabs to ensure isolation.",
        "priority": "high",
        "dependencies": ["6"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-20T21:14:52.754Z"
      },
      {
        "id": 8,
        "title": "Authentication & Network Access Control",
        "description": "Implement authentication and network-level access controls to restrict dashboard access to admin only. Configure Metabase security settings and Docker network isolation.",
        "details": "Security implementation:\n\n1. Metabase Authentication:\n```bash\n# In docker-compose.yml environment section\nMB_PASSWORD: ${METABASE_ADMIN_PASSWORD}\nMB_ALLOW_ANONYMOUS: \"false\"\nMB_DISABLE_SESSION_THROTTLING: \"false\"\nMB_SESSION_TIMEOUT: \"60\" # minutes\n```\n\n2. Generate strong admin password:\n```bash\n# generate-password.sh\nopenssl rand -base64 32 > secrets/admin-password.txt\n```\n\n3. Docker network isolation:\n```yaml\n# In docker-compose.yml\nnetworks:\n  admin-dashboard-net:\n    driver: bridge\n    ipam:\n      config:\n        - subnet: 172.20.0.0/16\nservices:\n  metabase:\n    networks:\n      admin-dashboard-net:\n        ipv4_address: 172.20.0.2\n```\n\n4. Host firewall rule (iptables):\n```bash\n# Only allow localhost access\niptables -A INPUT -p tcp --dport 3000 -s 127.0.0.1 -j ACCEPT\niptables -A INPUT -p tcp --dport 3000 -j DROP\n```\n\n5. Create admin access script that displays credentials:\n```bash\n# access-dashboard.sh\necho \"URL: http://localhost:3000\"\necho \"Username: admin\"\necho \"Password: $(cat secrets/admin-password.txt)\"\n```",
        "testStrategy": "Attempt access without password (should redirect to login). Test login with correct credentials. Verify failed login attempts are logged. Check that dashboard is not accessible from other machines on network. Run nmap scan to confirm port 3000 is not exposed externally. Validate session timeout after 60 minutes of inactivity.",
        "priority": "high",
        "dependencies": ["4"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-21T00:46:12.643Z"
      },
      {
        "id": 9,
        "title": "Manual Refresh & Cache Configuration",
        "description": "Configure Metabase cache settings to support manual refresh behavior and document the refresh process for on-demand data fetching. Optimize query performance for fresh data retrieval.",
        "details": "Implementation:\n\n1. Set Metabase cache to 0 (disable caching) for real-time data:\n```yaml\n# Environment variable\nMB_DB_QUERY_TIMEOUT: \"60000\"\nMB_ENABLE_QUERY_CACHING: \"false\"\n```\n\n2. Configure database-level settings in Metabase UI:\n   - Go to Admin > Databases > Firestore\n   - Set 'Default result cache duration' to 0 seconds\n   - Enable 'Rerun queries for simple explorations'\n\n3. Document manual refresh procedures in README.md:\n```markdown\n## Manual Refresh Options\n\n1. **Full Dashboard Refresh**: Press Ctrl+Shift+R or Cmd+Shift+R\n2. **Individual Question Refresh**: Click three dots on any metric > 'Refresh'\n3. **Metabase Sync**: Admin > Databases > Firestore > 'Sync database schema now'\n4. **API Trigger**: \n   ```bash\n   curl -X POST http://localhost:3000/api/database/1/rescan_values \\\n     -H \"X-Metabase-Session: ${SESSION_TOKEN}\"\n   ```\n```\n\n4. Create refresh script for admin:\n```bash\n# refresh-dashboard.sh\n#!/bin/bash\ncurl -s -X POST http://localhost:3000/api/database/1/sync_schema \\\n  -H \"X-Metabase-Session: $(cat .metabase-session)\" \\\n  && echo \"Dashboard data refreshed\"\n```\n\n5. Monitor query performance:\n```sql\n-- In Metabase, check query execution time\nEXPLAIN SELECT COUNT(*) FROM `users`;\n```",
        "testStrategy": "Load dashboard, modify data in Firestore console, then refresh and verify new data appears within 5 seconds. Test each refresh method documented. Monitor network tab to ensure no caching headers (Cache-Control: no-cache). Measure query execution time before and after cache disable. Test concurrent refresh requests to ensure stability.",
        "priority": "medium",
        "dependencies": ["6"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-20T21:14:52.766Z"
      },
      {
        "id": 10,
        "title": "Data Accuracy Validation & Spot-Checking",
        "description": "Create automated validation scripts to verify Metabase metrics accuracy against Firestore source data. Implement spot-checking procedures for admin to manually verify KPI correctness.",
        "details": "Validation implementation:\n\n1. Create Node.js validation script (validate-metrics.js):\n```javascript\nconst admin = require('firebase-admin');\nconst axios = require('axios');\n\n// Initialize Firebase Admin\nconst serviceAccount = require('./secrets/firebase-service-account.json');\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount)\n});\n\nconst firestore = admin.firestore();\n\nasync function validateMetrics() {\n  console.log('Starting validation...');\n  \n  // Get Firestore counts directly\n  const [userSnap, boardSnap, listSnap, cardSnap, commentSnap] = await Promise.all([\n    firestore.collection('users').count().get(),\n    firestore.collection('boards').count().get(),\n    firestore.collection('lists').count().get(),\n    firestore.collection('cards').count().get(),\n    firestore.collection('comments').count().get()\n  ]);\n  \n  const firestoreCounts = {\n    users: userSnap.data().count,\n    boards: boardSnap.data().count,\n    lists: listSnap.data().count,\n    cards: cardSnap.data().count,\n    comments: commentSnap.data().count\n  };\n  \n  // Get Metabase metrics via API\n  const session = await axios.post('http://localhost:3000/api/session', {\n    username: 'admin',\n    password: process.env.METABASE_PASSWORD\n  });\n  \n  const metabaseCounts = {};\n  for (const [key, questionId] of Object.entries({\n    users: 1, boards: 2, lists: 3, cards: 4, comments: 5\n  })) {\n    const response = await axios.post(\n      `http://localhost:3000/api/card/${questionId}/query`,\n      {},\n      { headers: { 'X-Metabase-Session': session.data.id } }\n    );\n    metabaseCounts[key] = response.data.data.rows[0][0];\n  }\n  \n  // Compare and report\n  let allMatch = true;\n  for (const key in firestoreCounts) {\n    const match = firestoreCounts[key] === metabaseCounts[key];\n    console.log(`${key}: Firestore=${firestoreCounts[key]}, Metabase=${metabaseCounts[key]} ${match ? '✓' : '✗'}`);\n    if (!match) allMatch = false;\n  }\n  \n  process.exit(allMatch ? 0 : 1);\n}\n\nvalidateMetrics().catch(console.error);\n```\n\n2. Add npm script:\n```json\n\"scripts\": {\n  \"validate\": \"node scripts/validate-metrics.js\"\n}\n```\n\n3. Create manual spot-check guide:\n```markdown\n## Manual Spot-Check Procedure\n\n1. Open Firestore Console and Metabase side-by-side\n2. For each collection:\n   - Firestore: Check collection counter\n   - Metabase: Run corresponding question\n   - Verify counts match exactly\n3. Test edge cases:\n   - Empty collections (should show 0)\n   - Large collections (>10k docs)\n   - Collections with nested data\n```\n\n4. Schedule validation in CI/CD:\n```yaml\n# .github/workflows/validate-metrics.yml\nname: Validate Metrics\non: [push]\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - run: npm install\n      - run: docker-compose up -d\n      - run: npm run validate\n```",
        "testStrategy": "Run validation script and verify exit code 0 when metrics match. Deliberately introduce a discrepancy by adding a test document to Firestore and confirm script detects mismatch (exit code 1). Test manual spot-check procedure with admin user. Validate script works with production data volumes. Check that validation completes in under 30 seconds.",
        "priority": "high",
        "dependencies": ["6"],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Fallback Custom Dashboard Scaffold",
        "description": "Initialize the fallback custom dashboard project structure using Remix and Express. Set up API layer architecture for direct Firestore queries if Metabase proves unsuitable.",
        "details": "Scaffold fallback implementation:\n\n1. Initialize Remix project:\n```bash\nnpx create-remix@latest driftboard-admin-fallback --template remix-run/indie-stack\ncd driftboard-admin-fallback\n```\n\n2. Install dependencies:\n```bash\nnpm install firebase-admin express cors dotenv\nnpm install -D @types/express concurrently\n```\n\n3. Create project structure:\n```\n/app\n  /routes\n    _index.tsx          # Main dashboard\n    users.$userId.tsx   # User details\n    boards.$boardId.tsx # Board details\n  /lib\n    firebase.server.ts  # Firebase Admin initialization\n    metrics.server.ts   # Metrics calculation\n/server\n  /api\n    metrics.ts          # Express API routes\n  index.ts              # Express server entry\n```\n\n4. Implement Firebase Admin initialization (app/lib/firebase.server.ts):\n```typescript\nimport * as admin from 'firebase-admin';\n\nlet firebaseApp: admin.app.App;\n\nexport function getFirebase() {\n  if (!firebaseApp) {\n    firebaseApp = admin.initializeApp({\n      credential: admin.credential.cert(\n        JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT!)\n      )\n    });\n  }\n  return firebaseApp.firestore();\n}\n```\n\n5. Create Express API stub (server/api/metrics.ts):\n```typescript\nimport { Router } from 'express';\nimport { getFirebase } from '../../app/lib/firebase.server';\n\nconst router = Router();\n\nrouter.get('/kpi', async (req, res) => {\n  // Stub: return mock data\n  res.json({\n    totalUsers: 0,\n    totalBoards: 0,\n    totalLists: 0,\n    totalCards: 0,\n    totalComments: 0\n  });\n});\n\nexport default router;\n```\n\n6. Add pivot criteria documentation:\n```markdown\n## When to Pivot to Custom Dashboard\n\nPivot if ANY of the following occurs:\n- Firestore connector fails to sync after 3 retry attempts\n- Query performance exceeds 10 seconds for simple counts\n- Drill-down navigation cannot be implemented via Metabase\n- Authentication requirements exceed Metabase capabilities\n```",
        "testStrategy": "Run 'npm run dev' and verify Remix app starts on port 3000. Test Express API stub at /api/metrics/kpi returns JSON. Verify Firebase Admin SDK initializes without errors. Check that environment variables load correctly. Test build process with 'npm run build' completes successfully.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Deployment Automation & Operational Documentation",
        "description": "Create comprehensive deployment automation scripts and operational documentation for local Docker deployment. Include health checks, troubleshooting guide, and quick-start procedures.",
        "details": "Implementation:\n\n1. Create deployment script (scripts/deploy.sh):\n```bash\n#!/bin/bash\nset -e\n\necho \"Starting Driftboard Admin Dashboard deployment...\"\n\n# Check prerequisites\ndocker --version > /dev/null || { echo \"Docker required\"; exit 1; }\ndocker-compose --version > /dev/null || { echo \"Docker Compose required\"; exit 1; }\n\n# Generate passwords if not exists\nif [ ! -f secrets/admin-password.txt ]; then\n  mkdir -p secrets\n  openssl rand -base64 32 > secrets/admin-password.txt\n  echo \"Generated admin password\"\nfi\n\n# Create .env file\nif [ ! -f .env ]; then\n  cp .env.template .env\n  echo \"Created .env file - please edit with your values\"\nfi\n\n# Start services\ndocker-compose up -d\n\n# Wait for Metabase to be healthy\necho \"Waiting for Metabase to start...\"\nsleep 30\n\n# Run health check\nuntil curl -sf http://localhost:3000/api/health; do\n  echo \"Waiting for Metabase...\"\n  sleep 5\ndone\n\n# Display access info\necho \"\"\necho \"=== Deployment Complete ===\"\necho \"URL: http://localhost:3000\"\necho \"Username: admin\"\necho \"Password: $(cat secrets/admin-password.txt)\"\necho \"\"\necho \"Next steps:\"\necho \"1. Configure Firestore connector in Metabase Admin\"\necho \"2. Import dashboards from metabase/ directory\"\necho \"3. Run validation: npm run validate\"\n```\n\n2. Create health check endpoint (scripts/health-check.sh):\n```bash\n#!/bin/bash\nMETABASE_STATUS=$(curl -s -o /dev/null -w \"%{http_code}\" http://localhost:3000/api/health)\nFIREBASE_STATUS=$(curl -s -o /dev/null -w \"%{http_code}\" https://firestore.googleapis.com/v1/projects/${FIREBASE_PROJECT_ID})\n\nif [ \"$METABASE_STATUS\" == \"200\" ] && [ \"$FIREBASE_STATUS\" == \"200\" ]; then\n  echo \"HEALTHY\"\n  exit 0\nelse\n  echo \"UNHEALTHY - Metabase: $METABASE_STATUS, Firebase: $FIREBASE_STATUS\"\n  exit 1\nfi\n```\n\n3. Create comprehensive README.md:\n```markdown\n# Driftboard Admin Dashboard\n\n## Quick Start\n```bash\ngit clone <repo>\ncd admin-dashboard\n./scripts/deploy.sh\n```\n\n## Configuration\n1. Copy `.env.template` to `.env`\n2. Add Firebase project ID\n3. Place service account at `secrets/firebase-service-account.json`\n\n## Troubleshooting\n- **Metabase won't start**: Check port 3000 is free\n- **Connector fails**: Verify service account has read-only role\n- **Data mismatch**: Run `npm run validate` and check Firestore indexes\n```\n\n4. Add Docker healthcheck to docker-compose.yml:\n```yaml\nhealthcheck:\n  test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/api/health\"]\n  interval: 30s\n  timeout: 10s\n  retries: 3\n  start_period: 60s\n```",
        "testStrategy": "Run deployment script on fresh VM and verify completion in under 5 minutes. Test health check script returns 'HEALTHY' when running. Verify README instructions work without modification. Test troubleshooting steps by simulating common failures (wrong credentials, port conflict). Validate that deployment can be completed by following only the README.",
        "priority": "medium",
        "dependencies": ["4", "5", "6", "7", "8", "9", "10"],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2026-01-21T00:46:15.101Z"
      },
      {
        "id": 13,
        "title": "Future-Proofing for Cloud Migration & Extensions",
        "description": "Structure the codebase for future monorepo integration and cloud deployment. Define environment variable schema, stub authentication middleware, and document extension points for Day 2 features.",
        "details": "Future-proofing implementation:\n\n1. Monorepo structure preparation:\n```\n/driftboard-monorepo\n  /apps\n    /admin-dashboard\n      /metabase        # Current implementation\n      /fallback        # Remix fallback\n  /packages\n    /config            # Shared config\n    /types             # Shared TypeScript types\n```\n\n2. Create environment variable schema (config/env.schema.ts):\n```typescript\nexport const envSchema = {\n  // Current MVP variables\n  METABASE_ADMIN_PASSWORD: z.string().min(16),\n  FIREBASE_PROJECT_ID: z.string(),\n  FIREBASE_SERVICE_ACCOUNT: z.string(),\n  \n  // Future cloud deployment variables\n  NODE_ENV: z.enum(['development', 'production']),\n  AUTH_TYPE: z.enum(['token', 'firebase-auth']).default('token'),\n  SESSION_SECRET: z.string().optional(),\n  \n  // Day 2 features\n  ENABLE_AUTO_REFRESH: z.boolean().default(false),\n  AUTO_REFRESH_INTERVAL: z.number().min(60).default(300),\n  ENABLE_TIME_FILTERS: z.boolean().default(true),\n  \n  // Vercel deployment\n  VERCEL_URL: z.string().optional(),\n  VERCEL_GIT_COMMIT_SHA: z.string().optional(),\n};\n```\n\n3. Stub authentication middleware (fallback/app/lib/auth.server.ts):\n```typescript\nexport async function requireAdmin(request: Request) {\n  const authType = process.env.AUTH_TYPE;\n  \n  if (authType === 'token') {\n    // Current token-based auth\n    const token = request.headers.get('Authorization')?.replace('Bearer ', '');\n    if (token !== process.env.ADMIN_TOKEN) {\n      throw new Response('Unauthorized', { status: 401 });\n    }\n  } else if (authType === 'firebase-auth') {\n    // Future: Firebase Auth integration\n    // TODO: Implement Firebase ID token verification\n    // const idToken = request.headers.get('Authorization')?.replace('Bearer ', '');\n    // await admin.auth().verifyIdToken(idToken);\n  }\n  \n  return true;\n}\n```\n\n4. Document extension points (docs/extensions.md):\n```markdown\n## Day 2 Feature Implementation Points\n\n### Time-Range Filters\n- Add date parameters to Metabase questions\n- Update queries with TIMESTAMP_WHERE clauses\n- UI: Add date picker to dashboard header\n\n### Auto-Refresh\n- Set MB_ENABLE_PUBLIC_SHARING=true\n- Use Metabase iframe with refresh meta tag\n- Or implement setInterval in React component\n\n### Vercel Deployment\n1. Set AUTH_TYPE=firebase-auth\n2. Add Firebase Auth UI from @firebase/auth\n3. Configure Vercel environment variables\n4. Update firebase.json for hosting\n```\n\n5. Create migration guide (docs/migration-to-cloud.md):\n```markdown\n## Migrating from Local Docker to Vercel\n\n### Prerequisites\n- Firebase project with Blaze plan\n- Custom domain (optional)\n\n### Steps\n1. Enable Firebase Authentication\n2. Add admin users to Firebase Auth\n3. Set AUTH_TYPE=firebase-auth\n4. Deploy fallback dashboard to Vercel\n5. Configure environment variables in Vercel dashboard\n6. Update DNS/settings for custom domain\n```",
        "testStrategy": "Validate that all environment variables load correctly using zod schema parsing. Test that auth middleware allows token-based auth and rejects invalid tokens. Verify stubbed Firebase Auth path doesn't break existing flow. Check that monorepo structure doesn't break current Docker build. Test that documentation is clear enough for future developer to implement Day 2 features without additional context.",
        "priority": "low",
        "dependencies": ["11"],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-21T00:46:15.101Z",
      "taskCount": 13,
      "completedCount": 1,
      "tags": ["separation"],
      "created": "2026-02-10T00:42:13.990Z",
      "description": "Tasks for separation context",
      "updated": "2026-02-10T00:42:13.990Z"
    }
  },
  "ui": {
    "tasks": [
      {
        "id": 1,
        "title": "Enhance Shared Boards with Visual Indicators and Access Lists",
        "description": "Implement visual indicators to show when a board is shared and display a list of users who have access to it, ensuring the access list is only visible to authorized users.",
        "details": "This task involves adding functionality to clearly identify shared boards and show who has access to them, while maintaining appropriate security controls. Implementation should include:\n\n1. Visual Indicator Component:\n   - Create a distinct visual element (icon/badge) that appears on shared boards\n   - Position the indicator consistently in the board UI (header or board card)\n   - Ensure indicator is visible to all users with access to the board\n\n2. Access List Component:\n   - Develop a UI component to display users who have access to the board\n   - Include user avatars, names, and potentially their access level\n   - Make the list accessible via an intuitive UI action (click/hover on share indicator)\n\n3. Visibility Logic:\n   - Implement conditional rendering for the access list based on user authorization\n   - Only show the access list to users who have been granted access to the board\n   - Add server-side validation to ensure access list data is only provided to authorized users\n\n4. Authentication Integration:\n   - Connect to existing authentication system to obtain current user information\n   - Use authentication status to determine whether a user should see specific board information\n\n5. Future Compatibility:\n   - Design the data structure to accommodate future 'public' boards without major refactoring\n   - Prepare for future role-based relationships (viewer/editor/owner) in the data model\n   - Document assumptions and design decisions for future developers\n\n6. Security Measures:\n   - Implement proper authorization checks on both client and server\n   - Ensure API endpoints that retrieve board sharing information verify user permissions\n   - Add appropriate error handling for unauthorized access attempts",
        "testStrategy": "To verify the correct implementation of the shared board enhancements:\n\n1. Unit Tests:\n   - Test the shared board indicator component renders correctly based on board sharing status\n   - Test access list component renders the correct users with proper formatting\n   - Test visibility logic correctly determines when to show/hide the access list\n\n2. Integration Tests:\n   - Verify the board sharing indicator appears only on boards that are actually shared\n   - Confirm the access list appears only when an authorized user interacts with the sharing indicator\n   - Test that users who don't have access to a board cannot see the access list\n\n3. Security Tests:\n   - Attempt to access the list of users for a board via API when not authorized\n   - Verify server properly rejects unauthorized requests for board access information\n   - Test that the front-end properly handles and displays authorization errors\n\n4. User Flow Tests:\n   - Create test scenarios with multiple users and shared boards\n   - Verify correct behavior when a user's access is revoked while they're viewing the board\n   - Test user experience when sharing/unsharing boards\n\n5. Cross-browser Testing:\n   - Verify the sharing indicator and access list display correctly across different browsers\n   - Test responsive behavior on different screen sizes\n\n6. Accessibility Testing:\n   - Verify new UI elements are keyboard accessible\n   - Test with screen readers to ensure proper announcements\n   - Check color contrast for visual indicators\n\nDocument test results with screenshots and clear pass/fail criteria.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create backend API endpoints for board sharing data",
            "description": "Implement RESTful API endpoints to retrieve board sharing status and access list data with proper authorization checks.",
            "dependencies": [],
            "details": "Create GET /api/boards/{id}/sharing endpoint that returns sharing status and access list. Implement server-side authorization to ensure only authorized users can access this data. Include user IDs, names, avatars, and access levels in the response. Add proper error handling for unauthorized requests returning 403 status codes.",
            "status": "done",
            "testStrategy": "Test API endpoint with authenticated and unauthenticated users. Verify correct data is returned for authorized users and 403 errors for unauthorized users. Test with various board sharing configurations.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build shared board visual indicator React component",
            "description": "Develop a reusable React component that displays a visual indicator when a board is shared.",
            "dependencies": [1],
            "details": "Create a ShareIndicator component that accepts board data as props. Use a users icon with a badge that appears when board.isShared is true. Position it consistently in the board header or card. Style with CSS for clear visibility. Make it clickable to open the access list. Ensure component is responsive and accessible with proper ARIA labels.",
            "status": "done",
            "testStrategy": "Unit test component rendering based on isShared prop. Test click handler functionality. Verify icon displays correctly and has proper accessibility attributes. Test component in both board header and board card contexts.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop access list display component",
            "description": "Create a React component to show the list of users with access to a shared board.",
            "dependencies": [1],
            "details": "Build AccessList component that displays user avatars, names, and access levels in a modal or dropdown overlay. Fetch data from /api/boards/{id}/sharing endpoint using React Query or similar. Include loading states, error handling, and empty state UI. Style with proper spacing, typography, and user-friendly layout. Implement close/on-click outside behavior.",
            "status": "done",
            "testStrategy": "Test component with mock user data including various access levels. Verify avatar rendering, name display, and access level badges. Test loading and error states. Ensure modal/dropdown opens and closes correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement authorization logic and security measures",
            "description": "Add client-side and server-side authorization checks to control access list visibility based on user permissions.",
            "dependencies": [1, 2],
            "details": "Implement useAuthorization hook to check user permissions against board access control list. Add conditional rendering logic to only show access list to authorized users. Enhance API endpoint with robust permission validation and audit logging. Add error boundaries for unauthorized access attempts. Implement rate limiting on sharing endpoints.",
            "status": "done",
            "testStrategy": "Integration tests for full authorization flow. Test that unauthorized users cannot see access list UI or API data. Verify API rejects unauthorized requests with proper error messages. Test security audit logs are created.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate authentication system and add future compatibility",
            "description": "Connect components to existing authentication system and prepare data structures for future enhancements.",
            "dependencies": [1, 2, 4],
            "details": "Integrate with existing auth provider to get current user info and pass to components. Update TypeScript interfaces to support future 'public' boards and role-based access levels (viewer/editor/owner). Add feature flags for gradual rollout. Create comprehensive documentation of design decisions, security model, and API contracts. Add JSDoc comments to all public functions.",
            "status": "done",
            "testStrategy": "End-to-end tests with real authentication flow. Test future data structure compatibility by mocking upcoming features. Verify documentation accuracy and completeness. Test feature flag functionality.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 2,
        "title": "Fix Card View Mobile Responsiveness and Layout Issues",
        "description": "Resolve mobile styling problems in card view including overflow from long URLs, cards exceeding screen width requiring horizontal scrolling, and mispositioned UI elements.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "## Problem Analysis & Reproduction\nFirst, reproduce the super-long card issue caused by URLs. Create test cards with:\n- Unbroken URLs longer than 50 characters\n- Mixed content with long words\n- Various content types (links, code blocks, long strings)\n\n## Mobile-First CSS Implementation\n\n### 1. Card Container Constraints\n```css\n.card-container {\n  max-width: 100vw;\n  width: 100%;\n  overflow-x: hidden;\n  padding: 0 12px; /* Add safe margins */\n  box-sizing: border-box;\n}\n\n@media (max-width: 768px) {\n  .card {\n    width: 100% !important;\n    min-width: auto !important;\n    margin: 8px 0;\n  }\n}\n```\n\n### 2. URL/Text Wrapping Fixes\n```css\n.card-content {\n  word-wrap: break-word;\n  overflow-wrap: break-word;\n  word-break: break-word;\n  min-width: 0; /* Critical for flexbox children */\n}\n\n/* Specific handling for anchor tags */\n.card-content a {\n  display: inline-block;\n  max-width: 100%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: normal;\n}\n```\n\n### 3. UI Element Positioning Audit\nReview and fix these specific mobile issues:\n- Card action buttons (edit, delete, share) - ensure they stack vertically or use proper touch targets (44x44px minimum)\n- Card metadata (dates, author) - reposition from absolute/fixed to flow layout\n- Checklist progress bars - constrain width to card boundaries\n- Labels/tags - implement wrapping container with flex-wrap\n\n### 4. Viewport & Meta Tag Verification\nEnsure HTML includes:\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=5.0\">\n```\n\n### 5. User Feedback Mechanism\nBefore finalizing implementation:\n- Create 2-3 design mockups showing different approaches\n- Deploy to staging environment with interactive examples\n- Collect feedback on: card padding, button placement, text size, scrolling behavior\n- Document specific device/browser combinations that exhibit issues\n\n## Implementation Steps\n1. Audit current card CSS for fixed widths and overflow properties\n2. Create a test suite with problematic content examples\n3. Implement responsive breakpoints (320px, 375px, 414px, 768px)\n4. Fix UI element positioning using flexbox/grid instead of absolute positioning\n5. Test on physical devices (iPhone SE, iPhone 13, Pixel 6, Samsung Galaxy)\n6. Gather user feedback via staging preview\n7. Iterate based on feedback before production deployment",
        "testStrategy": "## Testing Approach\n\n### 1. Content Overflow Testing\n- Create cards with URLs of varying lengths: 50, 100, 200+ characters\n- Test with unbroken text strings and mixed alphanumeric content\n- Verify no horizontal scrolling on viewport widths from 320px to 768px\n- Confirm text wraps cleanly without breaking word readability unnecessarily\n\n### 2. Device-Specific Testing Matrix\nTest on these physical devices or browser emulators:\n- **iOS**: iPhone SE (375x667), iPhone 13 (390x844), iPad Mini (768x1024)\n- **Android**: Pixel 6 (412x915), Samsung Galaxy S21 (360x780)\n- Verify in both portrait and landscape orientations\n\n### 3. UI Element Positioning Validation\n- Measure all interactive elements meet 44x44px minimum touch target size\n- Confirm action buttons are reachable with thumb navigation\n- Verify metadata elements don't overlap or obscure content\n- Test with system font sizes set to maximum accessibility settings\n\n### 4. Cross-Browser Compatibility\n- Safari iOS (14+)\n- Chrome Android (90+)\n- Firefox Mobile\n- Samsung Internet\n\n### 5. Performance Testing\n- Measure rendering time for boards with 50+ cards on mobile network\n- Ensure CSS changes don't negatively impact desktop performance\n- Check for layout thrashing or excessive repaints using Chrome DevTools\n\n### 6. User Acceptance Testing\n- Deploy to staging with at least 5 different board configurations\n- Provide feedback form specifically asking about: card readability, button accessibility, scrolling experience\n- Require sign-off from 3+ team members on different devices before production release",
        "subtasks": [
          {
            "id": 1,
            "title": "Reproduce and document mobile card layout issues",
            "description": "Create test cards with problematic content to reproduce the mobile responsiveness issues including long URLs, unbroken text strings, and various content types that cause overflow and horizontal scrolling.",
            "status": "done",
            "dependencies": [],
            "details": "Set up a test environment with cards containing: 1) URLs longer than 50 characters (test 50, 100, 200+ char lengths), 2) Unbroken text strings and mixed alphanumeric content, 3) Code blocks and long strings. Document current behavior with screenshots on different viewport sizes (320px, 375px, 414px, 768px). Create a test suite that can be reused for regression testing.",
            "testStrategy": "Document baseline behavior before fixes. Take screenshots of broken layouts on iPhone SE, iPhone 13, Pixel 6, and Samsung Galaxy viewports. Set up Playwright for automated visual regression testing if not already configured. Create visual regression tests using Playwright to capture baseline screenshots and detect layout changes.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement card container constraints and viewport meta tag",
            "description": "Apply CSS constraints to card containers to prevent overflow and ensure proper viewport scaling on mobile devices.",
            "status": "done",
            "dependencies": [1],
            "details": "Add viewport meta tag to HTML: <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=5.0'>. Implement .card-container CSS with max-width: 100vw, width: 100%, overflow-x: hidden, padding: 0 12px, and box-sizing: border-box. Add responsive breakpoint @media (max-width: 768px) to force cards to 100% width with margin adjustments.",
            "testStrategy": "Test on physical devices and browser dev tools. Verify no horizontal scrolling on viewport widths from 320px to 768px. Check that cards respect screen boundaries and don't exceed 100vw.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Fix URL and text wrapping in card content",
            "description": "Implement CSS rules to ensure proper text wrapping for URLs and long content within cards to prevent overflow.",
            "status": "done",
            "dependencies": [2],
            "details": "Apply to .card-content: word-wrap: break-word, overflow-wrap: break-word, word-break: break-word, and min-width: 0 (critical for flexbox children). For anchor tags: display: inline-block, max-width: 100%, overflow: hidden, text-overflow: ellipsis, white-space: normal. Test with the problematic content from subtask 1.",
            "testStrategy": "Verify text wraps cleanly without breaking layout. Test URLs of varying lengths (50, 100, 200+ characters). Confirm no horizontal scrolling and that text remains readable. Check that ellipsis appears when text overflows.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Audit and fix UI element positioning for mobile",
            "description": "Review and reposition all card UI elements (action buttons, metadata, progress bars, tags) using modern layout techniques instead of absolute positioning.",
            "status": "done",
            "dependencies": [2],
            "details": "Audit current CSS for absolute/fixed positioning. Convert to flexbox/grid layouts. Ensure action buttons meet 44x44px touch target minimum. Reposition card metadata (dates, author) to flow layout. Constrain checklist progress bars to card boundaries. Implement flex-wrap for labels/tags container. Test stacking behavior on narrow screens.",
            "testStrategy": "Test all interactive elements are reachable and properly sized. Verify touch targets meet accessibility standards. Check that metadata flows correctly and doesn't overlap. Test tag wrapping with multiple tags.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Deploy to staging and collect user feedback",
            "description": "Deploy the mobile responsiveness fixes to a staging environment with interactive examples and collect user feedback before production deployment.",
            "status": "done",
            "dependencies": [3, 4],
            "details": "Create 2-3 design mockups showing different approaches for card padding, button placement, text size, and scrolling behavior. Deploy to staging with interactive test cards. Set up feedback collection mechanism (survey, feedback form, or user testing sessions). Document specific device/browser combinations tested. Gather feedback from 5-10 users on mobile devices. Iterate based on feedback findings.\n<info added on 2026-01-14T04:54:03.490Z>\nCompleted local verification using Playwright visual regression tests on the dedicated test page (/test-visuals/card-layout). Tests confirm that long URLs and unbroken text now wrap correctly on mobile viewports at 320px and 390px widths.\n</info added on 2026-01-14T04:54:03.490Z>",
            "testStrategy": "Conduct user testing sessions on physical devices (iPhone SE, iPhone 13, Pixel 6, Samsung Galaxy). Collect quantitative data (task completion rates) and qualitative feedback. Perform final cross-browser testing before production push.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-14T04:39:05.373Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-14T04:39:05.374Z",
      "taskCount": 2,
      "completedCount": 1,
      "tags": ["ui"],
      "created": "2026-01-14T04:51:02.958Z",
      "description": "Tasks for ui context",
      "updated": "2026-01-14T05:08:18.734Z"
    }
  },
  "security": {
    "tasks": [
      {
        "id": 1,
        "title": "Secure Client-Side Board Sharing and Firestore Rules",
        "description": "Restrict Firestore access to board memberships and user data to authorized users only, addressing vulnerabilities exposed by client-side refactor.",
        "details": "The recent refactor moved board sharing logic to the client, relying on permissive `firestore.rules` (`allow read: if isAuthenticated()`). This allows any user to scrape membership data.\n\nAction Items:\n1. Modify `firestore.rules` to restrict `board_memberships` read access. Users should only read memberships for boards they own or are members of.\n2. Evaluate if a return to Server Actions/API is necessary for secure, efficient querying if rules become too complex.\n3. Ensure `users` collection access is scoped appropriately (e.g., only visible to shared board members).\n4. Verify no sensitive data (emails) is exposed to unauthorized users.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-01-11T17:46:59.004Z",
      "updated": "2026-01-11T17:47:03.924Z",
      "description": "Tasks related to security improvements and hardening."
    }
  }
}
