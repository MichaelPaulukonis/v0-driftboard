{
  "master": {
    "tasks": [
      {
        "id": 27,
        "title": "Create URL Detection Utility Function",
        "description": "Implement a reusable utility function that detects URLs in text and converts them to clickable links",
        "details": "Create a new file `lib/utils.ts` with a `linkifyText()` function that:\n\n1. Takes a string input and returns JSX\n2. Uses regex to identify URLs with http/https protocols\n3. Splits text into segments (regular text and URLs)\n4. Returns JSX with URLs wrapped in `<a>` tags with appropriate attributes\n5. Ensures links open in new tabs with `target=\"_blank\"` and `rel=\"noopener noreferrer\"`\n\nExample implementation:\n```typescript\nimport React from 'react';\n\nexport function linkifyText(text: string): React.ReactNode {\n  if (!text) return '';\n  \n  // Basic URL regex for http/https protocols\n  const urlRegex = /(https?:\\/\\/[^\\s]+)/g;\n  \n  // Split text by URLs\n  const parts = text.split(urlRegex);\n  \n  // Find all URLs in the text\n  const urls = text.match(urlRegex) || [];\n  \n  // Combine parts and URLs into a single array of React nodes\n  const result: React.ReactNode[] = [];\n  \n  parts.forEach((part, i) => {\n    // Add the text part\n    if (part) result.push(part);\n    \n    // Add the URL part (if there is one)\n    if (urls[i]) {\n      result.push(\n        <a \n          key={i} \n          href={urls[i]} \n          target=\"_blank\" \n          rel=\"noopener noreferrer\"\n          className=\"text-blue-600 hover:underline\"\n        >\n          {urls[i]}\n        </a>\n      );\n    }\n  });\n  \n  return result;\n}\n```",
        "testStrategy": "Create unit tests using Jest and React Testing Library to:\n1. Verify the function correctly identifies URLs with http/https protocols\n2. Test that non-URL text remains unchanged\n3. Confirm the function returns proper JSX with anchor tags\n4. Validate that anchor tags have correct attributes (href, target, rel)\n5. Test edge cases like empty strings, strings with only URLs, and strings with multiple URLs",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Enhance URL Detection Patterns",
        "description": "Extend the URL detection regex to support additional URL formats including www. patterns and localhost URLs",
        "details": "Modify the `linkifyText()` function in `lib/utils.ts` to enhance URL detection:\n\n1. Update the regex pattern to support three URL formats:\n   - URLs with http/https protocols\n   - URLs starting with www. (without protocol)\n   - localhost URLs with port numbers\n\n2. Ensure proper URL handling for each pattern:\n   - For www. patterns without protocol, prepend 'http://' to the href attribute\n   - For localhost URLs, ensure they work correctly with port numbers\n\nExample enhanced regex implementation:\n```typescript\n// Enhanced URL regex for multiple patterns\nconst urlRegex = /(https?:\\/\\/[^\\s]+)|(www\\.[^\\s]+)|(localhost:[0-9]+[^\\s]*)/g;\n\n// Function to normalize URL for href attribute\nconst normalizeUrl = (url: string): string => {\n  if (url.startsWith('www.')) {\n    return `http://${url}`;\n  }\n  if (url.startsWith('localhost')) {\n    return `http://${url}`;\n  }\n  return url;\n};\n\n// Update the anchor creation to use normalized URLs\n<a \n  key={i} \n  href={normalizeUrl(urls[i])} \n  target=\"_blank\" \n  rel=\"noopener noreferrer\"\n  className=\"text-blue-600 hover:underline\"\n>\n  {urls[i]}\n</a>\n```",
        "testStrategy": "Extend the existing unit tests to:\n1. Verify detection of www. patterns without protocols\n2. Test localhost URL detection with various port numbers\n3. Confirm proper URL normalization for href attributes\n4. Test mixed content with multiple URL formats\n5. Validate edge cases like malformed URLs and unusual patterns",
        "priority": "medium",
        "dependencies": [27],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Update Card Description Component",
        "description": "Integrate the URL detection utility with the card description component to render clickable links",
        "details": "Modify the `CardItem.tsx` component to use the linkifyText utility:\n\n1. Import the linkifyText function:\n```typescript\nimport { linkifyText } from '../lib/utils';\n```\n\n2. Update the card description rendering to use the linkifyText function:\n```typescript\n// Before:\n<p className=\"text-gray-700 mt-2\">{card.description}</p>\n\n// After:\n<p className=\"text-gray-700 mt-2\">{linkifyText(card.description)}</p>\n```\n\n3. Ensure the component correctly handles empty descriptions\n\n4. Verify that the styling of links integrates well with the existing card styling\n\n5. Test that links are clickable and open in new tabs\n\n6. Confirm that the plain text storage format is maintained when saving card descriptions",
        "testStrategy": "Create component tests using React Testing Library to:\n1. Verify links are correctly rendered in card descriptions\n2. Test that clicking links opens them in new tabs\n3. Confirm that non-URL text renders normally\n4. Test with various description content including multiple links\n5. Verify that editing and saving descriptions maintains the plain text format",
        "priority": "high",
        "dependencies": [27],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Update Comment Component",
        "description": "Integrate the URL detection utility with the comment component to render clickable links in comment content",
        "details": "Modify the `CommentItem.tsx` component to use the linkifyText utility:\n\n1. Import the linkifyText function:\n```typescript\nimport { linkifyText } from '../lib/utils';\n```\n\n2. Update the comment content rendering to use the linkifyText function:\n```typescript\n// Before:\n<p className=\"text-gray-600\">{comment.content}</p>\n\n// After:\n<p className=\"text-gray-600\">{linkifyText(comment.content)}</p>\n```\n\n3. Ensure the component correctly handles empty comments\n\n4. Verify that the styling of links integrates well with the existing comment styling\n\n5. Test that links are clickable and open in new tabs\n\n6. Confirm that the plain text storage format is maintained when saving comments",
        "testStrategy": "Create component tests using React Testing Library to:\n1. Verify links are correctly rendered in comments\n2. Test that clicking links opens them in new tabs\n3. Confirm that non-URL text renders normally\n4. Test with various comment content including multiple links\n5. Verify that adding new comments with URLs works correctly\n6. Test that the plain text format is maintained in the database",
        "priority": "high",
        "dependencies": [27],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Add Link Styling with Tailwind CSS",
        "description": "Implement consistent styling for links across the application using Tailwind CSS",
        "details": "Create and apply consistent link styling using Tailwind CSS:\n\n1. Define a standard link style in the linkifyText function:\n```typescript\n<a \n  key={i} \n  href={normalizeUrl(urls[i])} \n  target=\"_blank\" \n  rel=\"noopener noreferrer\"\n  className=\"text-blue-600 hover:underline transition-colors duration-200\"\n>\n  {urls[i]}\n</a>\n```\n\n2. Consider adding visual indicators for different link types (optional):\n```typescript\n// Function to determine link type and return appropriate classes\nconst getLinkClasses = (url: string): string => {\n  if (url.includes('github.com')) {\n    return 'text-purple-600 hover:underline';\n  }\n  if (url.startsWith('localhost')) {\n    return 'text-green-600 hover:underline';\n  }\n  return 'text-blue-600 hover:underline';\n};\n\n// Use in anchor tag\nclassName={getLinkClasses(urls[i])}\n```\n\n3. Ensure link styles are consistent with the application's design system\n\n4. Test the styling across different components and contexts\n\n5. Verify that link styles are accessible and meet contrast requirements",
        "testStrategy": "1. Manually test link styling across different components\n2. Verify that hover states work correctly\n3. Test link appearance in different contexts (card descriptions, comments)\n4. Check that link styling meets accessibility standards for color contrast\n5. Verify that any visual indicators for different link types work correctly\n6. Test on different browsers to ensure consistent appearance",
        "priority": "medium",
        "dependencies": [27, 29, 30],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Verify Export Functionality Compatibility",
        "description": "Ensure that the URL linking feature doesn't break the existing export functionality",
        "details": "Test and verify that the export functionality works correctly with the new URL linking feature:\n\n1. Review the current export implementation to understand how card descriptions and comments are processed\n\n2. Verify that the linkifyText function is only used for rendering and doesn't affect the stored text format\n\n3. Create test cases with various URL patterns in card descriptions and comments\n\n4. Test the export functionality with these test cases\n\n5. Verify that exported data contains the original plain text with URLs (not HTML)\n\n6. If any issues are found, modify the export function to ensure it uses the raw text data rather than the rendered HTML\n\nExample verification approach:\n```typescript\n// Ensure export function uses raw text data\nexport function exportBoard(board) {\n  return {\n    ...board,\n    cards: board.cards.map(card => ({\n      ...card,\n      // Use the raw description, not the rendered HTML\n      description: card.description,\n      comments: card.comments.map(comment => ({\n        ...comment,\n        // Use the raw content, not the rendered HTML\n        content: comment.content\n      }))\n    }))\n  };\n}\n```",
        "testStrategy": "1. Create integration tests that verify export functionality with URLs in content\n2. Test exporting boards with various URL patterns in descriptions and comments\n3. Verify that exported data contains the original plain text URLs\n4. Test importing exported data to ensure round-trip integrity\n5. Manually test the export feature with real-world examples\n6. Verify that exported data can be correctly imported into other systems if applicable",
        "priority": "high",
        "dependencies": [29, 30],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Create Comprehensive Test Suite",
        "description": "Develop a comprehensive test suite for the URL linking feature to ensure reliability and correctness",
        "details": "Create a comprehensive test suite covering all aspects of the URL linking feature:\n\n1. Unit tests for the linkifyText utility function:\n```typescript\ndescribe('linkifyText', () => {\n  it('should return empty string for empty input', () => {\n    const result = linkifyText('');\n    expect(result).toEqual('');\n  });\n\n  it('should return plain text for input without URLs', () => {\n    const text = 'This is plain text without URLs';\n    const result = linkifyText(text);\n    expect(result).toEqual([text]);\n  });\n\n  it('should convert http URLs to clickable links', () => {\n    const text = 'Check this link: http://example.com';\n    const result = linkifyText(text);\n    expect(result).toHaveLength(2);\n    expect(result[0]).toEqual('Check this link: ');\n    expect(result[1].props.href).toEqual('http://example.com');\n  });\n\n  // Additional tests for other URL patterns\n});\n```\n\n2. Component tests for CardItem and CommentItem:\n```typescript\ndescribe('CardItem with URL linking', () => {\n  it('should render clickable links in description', () => {\n    const card = {\n      id: '1',\n      title: 'Test Card',\n      description: 'Visit http://example.com for more info'\n    };\n    \n    const { getByText } = render(<CardItem card={card} />);\n    const link = getByText('http://example.com');\n    \n    expect(link.tagName).toBe('A');\n    expect(link.href).toBe('http://example.com/');\n    expect(link.target).toBe('_blank');\n  });\n});\n```\n\n3. Integration tests for the complete feature:\n```typescript\ndescribe('URL linking integration', () => {\n  it('should maintain plain text in storage while rendering clickable links', async () => {\n    // Setup test data\n    // Render components\n    // Verify links are clickable\n    // Update content with new URLs\n    // Verify storage format remains plain text\n    // Verify export functionality works correctly\n  });\n});\n```\n\n4. Create a manual testing checklist for real-world scenarios",
        "testStrategy": "1. Run the complete test suite using Jest and React Testing Library\n2. Verify all tests pass consistently\n3. Measure test coverage and ensure it meets project standards\n4. Perform manual testing using the created checklist\n5. Test with real-world URL examples from development workflow\n6. Verify browser compatibility across modern browsers\n7. Document any edge cases or limitations discovered during testing",
        "priority": "medium",
        "dependencies": [27, 28, 29, 30, 31, 32],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Document URL Linking Feature",
        "description": "Create documentation for the URL linking feature including implementation details and usage guidelines",
        "details": "Create comprehensive documentation for the URL linking feature:\n\n1. Update the project README.md with information about the new feature:\n```markdown\n## URL Linking\n\nDriftBoard now supports automatic URL detection and linking in card descriptions and comments. URLs are automatically converted to clickable links that open in new tabs.\n\nSupported URL formats:\n- Standard http/https URLs (e.g., https://example.com)\n- URLs starting with www (e.g., www.example.com)\n- Localhost URLs with port numbers (e.g., localhost:3000)\n\nThis feature makes it easier to reference external resources, documentation, and related items without breaking your workflow.\n```\n\n2. Add code documentation for the linkifyText utility function:\n```typescript\n/**\n * Converts URLs in text to clickable links\n * \n * @param text - The input text that may contain URLs\n * @returns React nodes with URLs converted to anchor tags\n * \n * Supported URL formats:\n * - http/https protocols (e.g., https://example.com)\n * - www patterns without protocol (e.g., www.example.com)\n * - localhost URLs with port numbers (e.g., localhost:3000)\n */\nexport function linkifyText(text: string): React.ReactNode {\n  // Implementation\n}\n```\n\n3. Create developer documentation explaining:\n   - How the feature works\n   - How to use it in new components\n   - Testing considerations\n   - Known limitations\n\n4. Update any user-facing documentation to explain the new feature",
        "testStrategy": "1. Review documentation for accuracy and completeness\n2. Verify code examples in documentation work correctly\n3. Have another team member review the documentation\n4. Test following the documentation to implement the feature in a new component\n5. Verify user-facing documentation clearly explains the feature",
        "priority": "low",
        "dependencies": [27, 28, 29, 30, 31, 32, 33],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Update Card Data Model with Status Field",
        "description": "Modify the existing card data model to include a unified status field that can track the lifecycle state of a card.",
        "details": "Update the card schema to include a 'status' field with possible values: 'active', 'done', 'archived', 'deleted'. Ensure all existing cards default to 'active' status. This is a critical foundation for the new views functionality. Avoid using separate boolean flags as specified in the PRD. Update any relevant TypeScript interfaces or database schemas accordingly. Example implementation:\n```typescript\ninterface Card {\n  id: string;\n  title: string;\n  content: string;\n  // other existing fields\n  status: 'active' | 'done' | 'archived' | 'deleted';\n}\n\n// Migration function for existing cards\nconst migrateExistingCards = async () => {\n  const cardRefs = await db.collection('cards').get();\n  const batch = db.batch();\n  \n  cardRefs.docs.forEach(doc => {\n    if (!doc.data().status) {\n      batch.update(doc.ref, { status: 'active' });\n    }\n  });\n  \n  return batch.commit();\n};\n```",
        "testStrategy": "1. Unit test the card model to ensure it correctly validates the status field.\n2. Write a test to verify the migration function correctly updates existing cards.\n3. Test edge cases where a card might have an invalid status value.\n4. Verify that the database schema correctly stores and retrieves the status field.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implement Status Change API Endpoints",
        "description": "Create or update API endpoints to handle changing a card's status between active, done, archived, and deleted states.",
        "details": "Implement RESTful endpoints or GraphQL mutations that allow changing a card's status. Ensure proper validation and error handling. The endpoints should handle the transition between any two states (e.g., active to done, deleted to active for restoration). Example implementation:\n```typescript\n// REST endpoint example\napp.put('/api/cards/:id/status', authenticate, async (req, res) => {\n  const { id } = req.params;\n  const { status } = req.body;\n  \n  if (!['active', 'done', 'archived', 'deleted'].includes(status)) {\n    return res.status(400).json({ error: 'Invalid status value' });\n  }\n  \n  try {\n    await db.collection('cards').doc(id).update({ status });\n    return res.status(200).json({ success: true });\n  } catch (error) {\n    console.error('Error updating card status:', error);\n    return res.status(500).json({ error: 'Failed to update card status' });\n  }\n});\n```",
        "testStrategy": "1. Unit test the API endpoints with valid and invalid status values.\n2. Integration test to verify the database is correctly updated when the endpoint is called.\n3. Test error handling for cases like non-existent cards or unauthorized access.\n4. Performance test to ensure the endpoint can handle multiple simultaneous status changes.",
        "priority": "high",
        "dependencies": [35],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Create Kebab Menu in Board Header",
        "description": "Add a kebab menu (three-dot icon) to the board's header area that will contain options to view Done, Archived, and Deleted cards.",
        "details": "Implement a dropdown menu triggered by a kebab icon (three vertical dots) in the board header. The menu should contain three options: 'View Done', 'View Archived', and 'View Deleted'. Use appropriate styling to match the existing UI. Example implementation:\n```jsx\nconst BoardHeader = () => {\n  const [menuOpen, setMenuOpen] = useState(false);\n  \n  const handleViewStatusItems = (status) => {\n    // Will be implemented in another task\n    console.log(`View ${status} items`);\n    setMenuOpen(false);\n  };\n  \n  return (\n    <div className=\"board-header\">\n      {/* Existing header content */}\n      \n      <div className=\"kebab-menu-container\">\n        <button \n          className=\"kebab-button\" \n          onClick={() => setMenuOpen(!menuOpen)}\n          aria-label=\"More options\"\n        >\n          <svg>...</svg> {/* Three dots icon */}\n        </button>\n        \n        {menuOpen && (\n          <div className=\"kebab-menu\">\n            <button onClick={() => handleViewStatusItems('done')}>View Done</button>\n            <button onClick={() => handleViewStatusItems('archived')}>View Archived</button>\n            <button onClick={() => handleViewStatusItems('deleted')}>View Deleted</button>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Unit test the component to ensure it renders correctly.\n2. Test that clicking the kebab icon opens the menu and displays the three options.\n3. Test that clicking outside the menu closes it.\n4. Verify that clicking each option triggers the correct handler function.\n5. Test accessibility features like keyboard navigation and screen reader compatibility.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Implement Firestore Queries for Status-Based Views",
        "description": "Create optimized Firestore queries to fetch cards based on their status (done, archived, deleted) for the respective views.",
        "details": "Implement efficient Firestore queries that filter cards by their status field. Consider adding appropriate indexes to optimize query performance. These queries will be used to populate the modal views. Example implementation:\n```typescript\n// Query functions for different status views\nconst fetchCardsByStatus = async (status, boardId) => {\n  try {\n    const cardsRef = db.collection('cards');\n    const query = cardsRef\n      .where('boardId', '==', boardId)\n      .where('status', '==', status)\n      .orderBy('updatedAt', 'desc'); // Most recently updated first\n    \n    const snapshot = await query.get();\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error(`Error fetching ${status} cards:`, error);\n    throw error;\n  }\n};\n\n// Example usage\nexport const fetchDoneCards = (boardId) => fetchCardsByStatus('done', boardId);\nexport const fetchArchivedCards = (boardId) => fetchCardsByStatus('archived', boardId);\nexport const fetchDeletedCards = (boardId) => fetchCardsByStatus('deleted', boardId);\n```",
        "testStrategy": "1. Unit test each query function with mock Firestore data.\n2. Test performance with varying numbers of cards to ensure queries remain efficient.\n3. Verify that the queries correctly filter by both board ID and status.\n4. Test error handling for database connection issues.\n5. Verify that the returned data structure matches what the UI components expect.",
        "priority": "high",
        "dependencies": [35],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Design and Implement Modal View Component",
        "description": "Create a reusable floating modal component that will display cards with a specific status (Done, Archived, or Deleted).",
        "details": "Implement a modal component that can be triggered from the kebab menu. The modal should display a list of cards with the selected status, allow viewing card details, and provide options to restore cards. The modal should be dismissible and follow accessibility best practices. Example implementation:\n```jsx\nconst StatusModal = ({ status, isOpen, onClose }) => {\n  const [cards, setCards] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    if (!isOpen) return;\n    \n    const fetchCards = async () => {\n      setLoading(true);\n      try {\n        // Use the appropriate fetch function based on status\n        const fetchFunction = {\n          'done': fetchDoneCards,\n          'archived': fetchArchivedCards,\n          'deleted': fetchDeletedCards\n        }[status];\n        \n        const boardId = getCurrentBoardId(); // Implement this function\n        const fetchedCards = await fetchFunction(boardId);\n        setCards(fetchedCards);\n        setError(null);\n      } catch (err) {\n        setError('Failed to load cards');\n        console.error(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchCards();\n  }, [isOpen, status]);\n  \n  return (\n    <div className={`modal ${isOpen ? 'open' : ''}`}>\n      <div className=\"modal-content\">\n        <div className=\"modal-header\">\n          <h2>{status.charAt(0).toUpperCase() + status.slice(1)} Items</h2>\n          <button onClick={onClose} aria-label=\"Close modal\">×</button>\n        </div>\n        \n        <div className=\"modal-body\">\n          {loading && <p>Loading...</p>}\n          {error && <p className=\"error\">{error}</p>}\n          {!loading && !error && cards.length === 0 && (\n            <p>No {status} items found.</p>\n          )}\n          \n          <ul className=\"card-list\">\n            {cards.map(card => (\n              <li key={card.id} className=\"card-item\">\n                <div className=\"card-title\">{card.title}</div>\n                <button onClick={() => viewCardDetails(card)}>View</button>\n                <button onClick={() => restoreCard(card)}>Restore</button>\n              </li>\n            ))}\n          </ul>\n        </div>\n      </div>\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Unit test the modal component rendering with different statuses.\n2. Test loading states, error states, and empty states.\n3. Verify that the modal correctly fetches and displays cards based on status.\n4. Test that the modal can be opened and closed properly.\n5. Test accessibility features including keyboard navigation, focus trapping, and screen reader compatibility.\n6. Verify that the View and Restore buttons trigger the correct functions.",
        "priority": "medium",
        "dependencies": [37, 38],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Implement Card Detail View in Modal",
        "description": "Create functionality to view the full details of a card when selected from the status-based modal views.",
        "details": "Implement a detailed view of a card that appears when a user selects a card from the Done, Archived, or Deleted views. This should display all relevant card information in a readable format. Example implementation:\n```jsx\nconst CardDetailView = ({ card, onClose, onRestore }) => {\n  if (!card) return null;\n  \n  return (\n    <div className=\"card-detail-container\">\n      <div className=\"card-detail-header\">\n        <h3>{card.title}</h3>\n        <button onClick={onClose} aria-label=\"Close detail view\">×</button>\n      </div>\n      \n      <div className=\"card-detail-content\">\n        <p>{card.content}</p>\n        \n        {/* Display other card properties like dates, tags, etc. */}\n        {card.createdAt && (\n          <div className=\"card-meta\">\n            <span>Created: {new Date(card.createdAt).toLocaleString()}</span>\n          </div>\n        )}\n        \n        {card.tags && card.tags.length > 0 && (\n          <div className=\"card-tags\">\n            {card.tags.map(tag => (\n              <span key={tag} className=\"tag\">{tag}</span>\n            ))}\n          </div>\n        )}\n      </div>\n      \n      <div className=\"card-detail-actions\">\n        <button \n          className=\"restore-button\" \n          onClick={() => onRestore(card)}\n        >\n          Restore to Board\n        </button>\n      </div>\n    </div>\n  );\n};\n\n// Usage within the StatusModal component\nconst StatusModal = ({ /* ... */ }) => {\n  const [selectedCard, setSelectedCard] = useState(null);\n  \n  const viewCardDetails = (card) => {\n    setSelectedCard(card);\n  };\n  \n  const closeCardDetails = () => {\n    setSelectedCard(null);\n  };\n  \n  // ... existing code\n  \n  return (\n    <div className=\"modal\">\n      {/* ... existing modal code */}\n      \n      {selectedCard && (\n        <CardDetailView \n          card={selectedCard} \n          onClose={closeCardDetails} \n          onRestore={restoreCard}\n        />\n      )}\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Unit test the CardDetailView component with various card data structures.\n2. Test that all card properties are correctly displayed.\n3. Verify that the close button properly dismisses the detail view.\n4. Test that the restore button triggers the correct function with the card data.\n5. Test accessibility features for the detail view.\n6. Verify that the component handles edge cases like missing or malformed card data.",
        "priority": "medium",
        "dependencies": [39],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Implement Card Restoration Functionality",
        "description": "Create the functionality to restore cards from Done, Archived, or Deleted status back to active status on the board.",
        "details": "Implement the logic to restore a card from any non-active status back to active status. When restored, the card should be placed at the top of its original list as specified in the PRD. Example implementation:\n```typescript\nconst restoreCard = async (card) => {\n  try {\n    // Update the card status to active\n    await db.collection('cards').doc(card.id).update({\n      status: 'active',\n      updatedAt: firebase.firestore.FieldValue.serverTimestamp()\n    });\n    \n    // Get the original list to place the card at the top\n    const listRef = db.collection('lists').doc(card.listId);\n    const listDoc = await listRef.get();\n    \n    if (listDoc.exists) {\n      // Get current cards in the list\n      const list = listDoc.data();\n      const cardIds = list.cardIds || [];\n      \n      // Add the restored card to the top of the list if not already present\n      if (!cardIds.includes(card.id)) {\n        const updatedCardIds = [card.id, ...cardIds];\n        await listRef.update({ cardIds: updatedCardIds });\n      }\n      \n      return true;\n    } else {\n      // If original list doesn't exist, add to the first available list\n      const listsSnapshot = await db.collection('lists')\n        .where('boardId', '==', card.boardId)\n        .limit(1)\n        .get();\n      \n      if (!listsSnapshot.empty) {\n        const firstList = listsSnapshot.docs[0];\n        const listData = firstList.data();\n        const cardIds = listData.cardIds || [];\n        \n        await firstList.ref.update({\n          cardIds: [card.id, ...cardIds]\n        });\n        \n        // Update the card's listId to match its new location\n        await db.collection('cards').doc(card.id).update({\n          listId: firstList.id\n        });\n        \n        return true;\n      }\n      \n      throw new Error('No valid list found for card restoration');\n    }\n  } catch (error) {\n    console.error('Error restoring card:', error);\n    throw error;\n  }\n};\n```",
        "testStrategy": "1. Unit test the restoration function with various card and list scenarios.\n2. Test the edge case where the original list no longer exists.\n3. Verify that the card is correctly placed at the top of its list after restoration.\n4. Test error handling for database failures.\n5. Integration test to ensure the UI updates correctly after a card is restored.\n6. Verify that the card's status is correctly updated in the database.",
        "priority": "high",
        "dependencies": [36, 39],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Update Card Actions to Support Status Changes",
        "description": "Modify existing card action menus or buttons to allow users to mark cards as Done, Archive them, or Delete them.",
        "details": "Update the existing card UI to include options for changing a card's status. This could be through an existing card menu or by adding new buttons/actions. Example implementation:\n```jsx\nconst CardActions = ({ card }) => {\n  const [menuOpen, setMenuOpen] = useState(false);\n  \n  const handleStatusChange = async (newStatus) => {\n    try {\n      await updateCardStatus(card.id, newStatus);\n      setMenuOpen(false);\n      // Trigger any necessary UI updates or notifications\n    } catch (error) {\n      console.error(`Error changing card status to ${newStatus}:`, error);\n      // Show error notification\n    }\n  };\n  \n  return (\n    <div className=\"card-actions\">\n      <button \n        className=\"card-menu-button\" \n        onClick={() => setMenuOpen(!menuOpen)}\n        aria-label=\"Card actions\"\n      >\n        ⋮\n      </button>\n      \n      {menuOpen && (\n        <div className=\"card-menu\">\n          {/* Existing card actions */}\n          <button onClick={() => handleStatusChange('done')}>Mark as Done</button>\n          <button onClick={() => handleStatusChange('archived')}>Archive</button>\n          <button onClick={() => handleStatusChange('deleted')}>Delete</button>\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Helper function to update card status\nconst updateCardStatus = async (cardId, status) => {\n  try {\n    await db.collection('cards').doc(cardId).update({\n      status,\n      updatedAt: firebase.firestore.FieldValue.serverTimestamp()\n    });\n    return true;\n  } catch (error) {\n    console.error('Error updating card status:', error);\n    throw error;\n  }\n};\n```",
        "testStrategy": "1. Unit test the CardActions component with different card states.\n2. Test that clicking each status option correctly triggers the status change function.\n3. Verify that the menu opens and closes properly.\n4. Test error handling for failed status updates.\n5. Integration test to ensure the card disappears from the board when its status is changed.\n6. Verify that the UI is updated correctly after a status change.",
        "priority": "medium",
        "dependencies": [36],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "Update Board View to Filter Out Non-Active Cards",
        "description": "Modify the main board view to only display cards with 'active' status, hiding Done, Archived, and Deleted cards.",
        "details": "Update the board's card fetching logic to only retrieve and display cards with 'active' status. This will ensure that Done, Archived, and Deleted cards are hidden from the main board view. Example implementation:\n```typescript\n// Update the existing function that fetches cards for the board\nconst fetchBoardCards = async (boardId) => {\n  try {\n    const cardsRef = db.collection('cards');\n    const query = cardsRef\n      .where('boardId', '==', boardId)\n      .where('status', '==', 'active'); // Only fetch active cards\n    \n    const snapshot = await query.get();\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error fetching board cards:', error);\n    throw error;\n  }\n};\n\n// Update the board component to use this filtered query\nconst Board = ({ boardId }) => {\n  const [cards, setCards] = useState([]);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    const loadBoardData = async () => {\n      setLoading(true);\n      try {\n        const boardCards = await fetchBoardCards(boardId);\n        setCards(boardCards);\n      } catch (error) {\n        console.error('Error loading board:', error);\n        // Handle error\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    loadBoardData();\n    \n    // Set up real-time listener for card changes\n    const unsubscribe = db.collection('cards')\n      .where('boardId', '==', boardId)\n      .where('status', '==', 'active')\n      .onSnapshot(snapshot => {\n        const changes = snapshot.docChanges();\n        // Process changes and update the cards state\n        // ...\n      });\n    \n    return () => unsubscribe();\n  }, [boardId]);\n  \n  // Render the board with the filtered cards\n  // ...\n};\n```",
        "testStrategy": "1. Unit test the updated card fetching function to ensure it only returns active cards.\n2. Test the real-time listener to verify it correctly updates when cards change status.\n3. Integration test to ensure the board view updates correctly when a card's status changes.\n4. Performance test to verify that filtering doesn't negatively impact board loading time.\n5. Verify that cards with non-active statuses are properly hidden from the board view.",
        "priority": "high",
        "dependencies": [35, 38],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Implement UI Feedback for Status Changes",
        "description": "Add visual feedback when a card's status changes, such as confirmation messages or animations.",
        "details": "Implement user feedback mechanisms for status change actions to improve the user experience. This should include success/error notifications and potentially subtle animations for card transitions. Example implementation:\n```jsx\n// Toast notification component\nconst Toast = ({ message, type, onClose }) => {\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      onClose();\n    }, 3000); // Auto-close after 3 seconds\n    \n    return () => clearTimeout(timer);\n  }, [onClose]);\n  \n  return (\n    <div className={`toast ${type}`}>\n      <span>{message}</span>\n      <button onClick={onClose} aria-label=\"Dismiss notification\">×</button>\n    </div>\n  );\n};\n\n// Toast container component\nconst ToastContainer = () => {\n  const [toasts, setToasts] = useState([]);\n  \n  // Add this to your global context or use a pub/sub system\n  window.showToast = (message, type = 'info') => {\n    const id = Date.now();\n    setToasts(prev => [...prev, { id, message, type }]);\n  };\n  \n  const removeToast = (id) => {\n    setToasts(prev => prev.filter(toast => toast.id !== id));\n  };\n  \n  return (\n    <div className=\"toast-container\">\n      {toasts.map(toast => (\n        <Toast \n          key={toast.id}\n          message={toast.message}\n          type={toast.type}\n          onClose={() => removeToast(toast.id)}\n        />\n      ))}\n    </div>\n  );\n};\n\n// Usage in card status change functions\nconst handleStatusChange = async (card, newStatus) => {\n  try {\n    await updateCardStatus(card.id, newStatus);\n    \n    // Show success notification\n    const statusMessages = {\n      'done': 'Card marked as done',\n      'archived': 'Card archived',\n      'deleted': 'Card deleted',\n      'active': 'Card restored to board'\n    };\n    \n    window.showToast(statusMessages[newStatus] || 'Status updated', 'success');\n    \n    // Add animation class to the card if it's still in the DOM\n    const cardElement = document.getElementById(`card-${card.id}`);\n    if (cardElement && newStatus !== 'active') {\n      cardElement.classList.add('card-exit-animation');\n      setTimeout(() => {\n        // The card will be removed from the DOM by React when the data updates\n      }, 300); // Match this to your animation duration\n    }\n  } catch (error) {\n    console.error(`Error changing card status to ${newStatus}:`, error);\n    window.showToast(`Failed to update card: ${error.message}`, 'error');\n  }\n};\n```",
        "testStrategy": "1. Unit test the Toast and ToastContainer components.\n2. Test that notifications appear with the correct message for each status change.\n3. Verify that notifications auto-dismiss after the specified timeout.\n4. Test that animations play correctly when a card's status changes.\n5. Verify that error messages are displayed appropriately when status changes fail.\n6. Test that the UI remains responsive during status change operations.",
        "priority": "low",
        "dependencies": [42, 43],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Analyze and refactor CardDetailDialog component",
        "description": "Analyze the existing CardDetailDialog component structure and prepare it for inline editing capabilities",
        "details": "1. Review the current implementation of `components/card-detail-dialog.tsx`\n2. Identify areas where title and description are rendered\n3. Refactor the component to support state management for editing mode\n4. Create state variables for tracking edit modes (isEditingTitle, isEditingDescription)\n5. Ensure the component structure can accommodate the new UI elements\n6. Extract reusable logic from `components/edit-card-dialog.tsx` that can be used for inline editing\n7. Set up proper TypeScript interfaces for the component props and state\n8. Ensure accessibility is maintained throughout the refactoring",
        "testStrategy": "1. Create unit tests to verify the component renders correctly in both view and edit modes\n2. Test that state transitions work as expected when toggling between modes\n3. Verify that the component maintains all existing functionality\n4. Use React Testing Library to test component rendering and state management",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Implement inline title editing",
        "description": "Enable users to edit the card title directly within the card detail dialog by clicking on it",
        "details": "1. Modify the title display in `components/card-detail-dialog.tsx` to be clickable\n2. Implement a state toggle when the title is clicked to switch to edit mode\n3. Replace the title display with an input field when in edit mode\n4. Add event handlers for:\n   - Save on Enter key press\n   - Cancel on Escape key press\n   - Save on blur (clicking away)\n5. Reuse the card update logic from the existing codebase\n6. Implement optimistic UI updates for a responsive feel\n7. Add visual feedback during the saving process\n8. Handle potential errors during save operations\n9. Ensure the input field is properly styled to match the design system",
        "testStrategy": "1. Unit test the title edit functionality using React Testing Library\n2. Test all edge cases: empty titles, very long titles, special characters\n3. Test keyboard interactions (Enter to save, Escape to cancel)\n4. Test blur behavior\n5. Mock the Firebase service and verify it's called with correct parameters\n6. Test error handling scenarios\n7. Verify the UI updates optimistically before the backend confirms the change",
        "priority": "high",
        "dependencies": [45],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Implement inline description editing",
        "description": "Allow users to edit the card description directly within the card detail dialog with dedicated save and cancel buttons",
        "details": "1. Modify the description display in `components/card-detail-dialog.tsx` to be clickable\n2. Implement a state toggle when the description is clicked to switch to edit mode\n3. Replace the description display with a textarea when in edit mode\n4. Add 'Save' and 'Cancel' buttons below the textarea\n5. Implement handlers for the save and cancel actions\n6. Reuse the card update logic from the existing codebase\n7. Implement optimistic UI updates for a responsive feel\n8. Add visual feedback during the saving process\n9. Handle potential errors during save operations\n10. Ensure the textarea is properly styled and supports auto-resizing based on content\n11. Maintain markdown support if the current description supports it",
        "testStrategy": "1. Unit test the description edit functionality using React Testing Library\n2. Test all edge cases: empty descriptions, very long descriptions, markdown content\n3. Test the Save and Cancel button functionality\n4. Mock the Firebase service and verify it's called with correct parameters\n5. Test error handling scenarios\n6. Verify the UI updates optimistically before the backend confirms the change\n7. Test that the textarea properly resizes with content",
        "priority": "high",
        "dependencies": [45],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Add Archive and Delete action buttons",
        "description": "Add Archive and Delete buttons to the card detail dialog and implement their functionality",
        "details": "1. Design and add Archive and Delete buttons to the card detail dialog\n2. Position the buttons appropriately in the UI (likely in a footer or header area)\n3. Implement click handlers for both actions\n4. For Archive:\n   - Call the appropriate function from `lib/firebase-service.ts`\n   - Close the dialog after successful archiving\n   - Update the board UI to remove the archived card\n5. For Delete:\n   - Implement a confirmation dialog using a modal or toast\n   - Only proceed with deletion after user confirmation\n   - Call the appropriate function from `lib/firebase-service.ts`\n   - Close the dialog after successful deletion\n   - Update the board UI to remove the deleted card\n6. Add appropriate visual styling and hover states for the buttons\n7. Include proper icons for each action",
        "testStrategy": "1. Unit test the presence and styling of the action buttons\n2. Test the click handlers for both buttons\n3. For Delete, test that the confirmation dialog appears and works correctly\n4. Mock the Firebase service and verify it's called with correct parameters\n5. Test that the dialog closes after successful operations\n6. Verify the board UI updates correctly after operations\n7. Test error handling scenarios",
        "priority": "high",
        "dependencies": [45],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Implement Mark as Done functionality",
        "description": "Add a Mark as Done button to the card detail dialog to allow users to quickly change a card's status",
        "details": "1. Design and add a Mark as Done button to the card detail dialog\n2. Position the button appropriately in the UI\n3. Implement a click handler for the action\n4. Determine the current status of the card and toggle it appropriately\n5. Call the appropriate function from `lib/firebase-service.ts` to update the card status\n6. Implement optimistic UI updates for a responsive feel\n7. Add visual feedback during the saving process\n8. Handle potential errors during save operations\n9. Consider making this a toggle button that shows different text based on current status (e.g., 'Mark as Done' vs 'Mark as To Do')\n10. Add appropriate visual styling and hover states for the button",
        "testStrategy": "1. Unit test the presence and styling of the Mark as Done button\n2. Test the click handler functionality\n3. Test that the button text/appearance changes based on the card's current status\n4. Mock the Firebase service and verify it's called with correct parameters\n5. Verify the UI updates optimistically before the backend confirms the change\n6. Test error handling scenarios",
        "priority": "medium",
        "dependencies": [45, 48],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Implement offline editing support",
        "description": "Enable users to edit cards while offline with appropriate caching and synchronization when connection is restored",
        "details": "1. Implement a connection status detector using browser APIs (navigator.onLine and related events)\n2. Create a local cache mechanism for storing edits made while offline\n3. When a user attempts to save changes while offline:\n   - Store the changes in local storage or IndexedDB\n   - Show a visual indicator that the changes are pending sync\n   - Add the change to a queue of pending operations\n4. When the connection is restored:\n   - Detect the online status change\n   - Process the queue of pending operations\n   - Update the UI as operations succeed or fail\n   - Show appropriate notifications to the user\n5. Handle conflict resolution using a 'last-write-wins' strategy as specified in the PRD\n6. Implement appropriate error handling for failed synchronizations\n7. Consider using a library like Workbox for offline support if appropriate",
        "testStrategy": "1. Test the connection status detection mechanism\n2. Test the local caching of edits while offline\n3. Test the synchronization process when connection is restored\n4. Simulate various network conditions to verify robustness\n5. Test conflict resolution scenarios\n6. Verify that appropriate notifications are shown to the user\n7. Test that the UI correctly reflects the sync status of changes",
        "priority": "medium",
        "dependencies": [46, 47, 48, 49],
        "status": "deferred",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Implement permissions handling",
        "description": "Ensure that editing capabilities are only available to users with appropriate permissions",
        "details": "1. Review the existing permissions model in the application\n2. Modify the CardDetailDialog component to check user permissions before showing edit controls\n3. Implement conditional rendering of edit functionality based on permissions\n4. Add appropriate error handling for cases where a user without permissions attempts to edit\n5. Create clear error messages for permission-related issues\n6. Ensure that the Firebase security rules in `firestore.rules` are respected\n7. Add client-side validation to prevent unauthorized edit attempts\n8. Handle API errors related to permissions gracefully with user-friendly messages",
        "testStrategy": "1. Test rendering of the component with different user permission levels\n2. Verify that edit controls are only visible to users with appropriate permissions\n3. Test error handling when unauthorized edit attempts occur\n4. Mock different permission scenarios and verify the component behaves correctly\n5. Test integration with Firebase security rules\n6. Verify that appropriate error messages are shown to users without permissions",
        "priority": "high",
        "dependencies": [46, 47, 48],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Implement concurrent editing notifications",
        "description": "Add notifications to inform users when another user has made changes to the card they are viewing",
        "details": "1. Implement a mechanism to detect when a card has been modified by another user\n2. This could use Firestore's real-time capabilities to listen for document changes\n3. When a change is detected while a user is viewing a card:\n   - Show a non-intrusive notification (toast or banner)\n   - Inform the user that the card has been updated\n   - Offer an option to refresh the view with the latest data\n4. Implement the refresh functionality to update the card data\n5. Ensure the notification is dismissible\n6. Handle edge cases such as multiple rapid updates\n7. Consider implementing a cooldown period for notifications to prevent spam\n8. This is a 'nice-to-have' feature as specified in the PRD",
        "testStrategy": "1. Test the change detection mechanism using mock Firestore events\n2. Verify that notifications appear correctly when changes are detected\n3. Test the refresh functionality to ensure it updates the card data\n4. Test edge cases like multiple rapid updates\n5. Verify that notifications are dismissible\n6. Test the integration with Firestore's real-time capabilities",
        "priority": "low",
        "dependencies": [46, 47, 48, 49],
        "status": "deferred",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Implement comprehensive error handling",
        "description": "Create a robust error handling system for all card editing operations",
        "details": "1. Identify all possible error scenarios in the card editing workflow\n2. Implement appropriate error handling for each scenario:\n   - Network errors\n   - Permission errors\n   - Validation errors\n   - Concurrent editing conflicts\n   - Server errors\n3. Create user-friendly error messages for each error type\n4. Use the existing `use-toast.ts` hook to display error notifications\n5. Implement retry mechanisms where appropriate\n6. Preserve user input when errors occur to prevent data loss\n7. Log errors appropriately for debugging purposes\n8. Consider implementing a global error boundary for unexpected errors",
        "testStrategy": "1. Test each identified error scenario to verify proper handling\n2. Verify that appropriate error messages are displayed to users\n3. Test retry mechanisms where implemented\n4. Verify that user input is preserved when errors occur\n5. Test integration with the toast notification system\n6. Simulate various error conditions to ensure robustness",
        "priority": "medium",
        "dependencies": [46, 47, 48, 49, 50],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "Conduct comprehensive testing and performance optimization",
        "description": "Perform thorough testing of all implemented features and optimize performance to meet the sub-500ms response requirement",
        "details": "1. Create a comprehensive test plan covering all implemented features\n2. Implement end-to-end tests using Cypress or a similar tool\n3. Conduct performance testing to ensure all operations complete within 500ms as specified in the PRD\n4. Optimize component rendering using React best practices:\n   - Memoization with useMemo and useCallback\n   - Proper use of React.memo for component memoization\n   - Efficient state management\n5. Implement performance monitoring to track response times\n6. Optimize Firebase queries and updates\n7. Implement loading states and skeletons for operations that might take time\n8. Test on various devices and network conditions\n9. Address any accessibility issues identified during testing\n10. Document any performance optimizations for future reference",
        "testStrategy": "1. Run the comprehensive test suite covering all features\n2. Conduct performance testing using browser dev tools and custom timing measurements\n3. Test on various devices and network conditions including throttled connections\n4. Use Lighthouse or similar tools to assess performance metrics\n5. Verify that all operations meet the sub-500ms requirement specified in the PRD\n6. Test accessibility using automated tools and manual testing",
        "priority": "medium",
        "dependencies": [46, 47, 48, 49, 50, 51, 52, 53],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "Improve discoverability of UI actions and shortcuts",
        "description": "Investigate and implement UI patterns to improve the discoverability of non-obvious features and actions. This includes keyboard shortcuts like Cmd+Enter and actions hidden in menus.",
        "details": "1. Identify features lacking visual discoverability.\n2. Research and propose UI solutions like tooltips, help dialogs, or subtle UI hints.",
        "testStrategy": "",
        "status": "deferred",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 56,
        "title": "Refactor Card Actions into Kebab Menu",
        "description": "Replace the action buttons in the card detail dialog with a cleaner kebab menu.",
        "details": "1. Remove the DialogFooter containing the Archive, Delete, and Mark as Done buttons from CardDetailDialog.tsx.\n2. Add a MoreVertical icon button to the DialogHeader, aligned to the right.\n3. Use the DropdownMenu component from shadcn/ui to create the menu.\n4. Add DropdownMenuItems for 'Mark as Done'/'Mark as Active', 'Archive', and 'Delete'.\n5. Connect the existing handler functions to these new menu items.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 57,
        "title": "Implement Universal Cmd+Enter Save Shortcut",
        "description": "Implement Cmd+Enter (or Ctrl+Enter) as a universal shortcut for saving changes in editable fields.",
        "details": "1. In CardDetailDialog.tsx, modify the onKeyDown handler for the title Input.\n   - It should now save only on Cmd/Ctrl+Enter or blur.\n   - Pressing Enter alone should do nothing.\n2. Modify the onKeyDown handler for the description Textarea.\n   - It should save on Cmd/Ctrl+Enter.\n   - Pressing Enter alone should continue to create a new line.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 58,
        "title": "Research and Implement a Firestore Mocking Library",
        "description": "Our current test setup uses a manual, ad-hoc mock for Firestore. This can be brittle and hard to maintain. This task is to research, select, and implement a dedicated Firestore mocking library to improve test reliability.",
        "details": "1. Investigate modern libraries for mocking Firestore in a Vitest environment (e.g., firestore-jest-mock, @firebase/rules-unit-testing, or others).\n2. Select the most suitable library based on features, maintenance, and compatibility.\n3. Refactor `vitest.setup.ts` to replace the manual Firestore mock with the new library.\n4. Update existing tests that rely on the old mock to use the new library's API.",
        "testStrategy": "",
        "status": "deferred",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 59,
        "title": "Implement Keyboard Shortcuts in Comment Form",
        "description": "Refactor `components/comment-form.tsx` to add keyboard shortcuts. `Ctrl/Cmd + Enter` will submit the comment. `Escape` will clear the comment textarea. This ensures consistency with other editable fields in the application.",
        "details": "- Extract submission logic from `handleSubmit` into a new `submitComment` function.\n- The `form`'s `onSubmit` handler should call `e.preventDefault()` and then `submitComment`.\n- Add an `onKeyDown` handler to the `Textarea`.\n- In `onKeyDown`, if `Ctrl/Cmd + Enter` is pressed, call `submitComment` and `e.preventDefault()`.\n- In `onKeyDown`, if `Escape` is pressed, clear the content state and call `e.stopPropagation()` to prevent the dialog from closing.",
        "testStrategy": "Manual testing: Open the card detail dialog. \n1. Type a comment and press `Ctrl/Cmd + Enter` to verify it's submitted. \n2. Type a comment and press `Escape` to verify the field is cleared and the dialog remains open. \n3. Verify that pressing `Enter` alone creates a new line.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 60,
        "title": "Add Escape Key Handling to Card Description Editing",
        "description": "In `components/card-detail-dialog.tsx`, the description `Textarea` does not handle the `Escape` key to cancel editing. This is inconsistent with the title editing. This task is to add an `onKeyDown` handler to the description `Textarea` to cancel the edit on `Escape`.",
        "details": "- In `components/card-detail-dialog.tsx`, locate the `Textarea` for the description.\n- Add an `onKeyDown` handler.\n- Inside the handler, check for the `Escape` key.\n- If `Escape` is pressed, call `setIsEditingDescription(false)` and reset the `description` state to `card.description || ''`.\n- It may be necessary to call `e.stopPropagation()` to prevent the dialog from closing.",
        "testStrategy": "Manual testing: \n1. Open a card and click to edit the description. \n2. Type something. \n3. Press `Escape`. \n4. Verify that the edit mode is cancelled, the changes are discarded, and the dialog is still open.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 61,
        "title": "Audit Data-Entry Fields for Keyboard Shortcut Consistency",
        "description": "Review all input fields, textareas, and forms in the application. Ensure that `Ctrl/Cmd + Enter` is consistently used for submission and `Escape` is used for cancellation of an edit. This audit should cover all dialogs and inline editing components.",
        "details": "- Identify all components with data entry fields (e.g., `create-board-dialog`, `create-list-dialog`, `create-card-dialog`, `edit-board-dialog`, etc.).\n- For each component, check the behavior of `Enter`, `Ctrl/Cmd + Enter`, and `Escape`.\n- Create a list of components that are inconsistent.\n- For each inconsistency, create a new task with details on how to fix it.",
        "testStrategy": "Manual testing across all forms and editable fields in the application. Create a checklist of components to review.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 62,
        "title": "Add Ctrl/Cmd+Enter Shortcut to Description Fields in Dialogs",
        "description": "In several dialogs, the `description` Textarea does not submit the form on `Ctrl/Cmd + Enter`. This is inconsistent with other parts of the application. This task is to add this keyboard shortcut to the description Textarea in the identified components.",
        "details": "Update the following files:\n- `components/create-board-dialog.tsx`\n- `components/create-card-dialog.tsx`\n- `components/edit-board-dialog.tsx`\n- `components/edit-card-dialog.tsx`\n\nFor each file, add an `onKeyDown` handler to the description `Textarea`. The handler should check for `Ctrl/Cmd + Enter` and, if detected, it should programmatically submit the form.",
        "testStrategy": "For each of the four dialogs: \n1. Open the dialog. \n2. Fill in the title. \n3. Type a description. \n4. Press `Ctrl/Cmd + Enter` while focused on the description field. \n5. Verify that the form is submitted successfully.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 63,
        "title": "Automate App Version Bumping and Display in UI",
        "description": "Create a process to automatically increment the application version in `package.json` upon release. Also, make the current app version visible somewhere in the UI, like the footer or a settings page, for easier debugging and user reference.",
        "details": "- Investigate tools for automating version bumps (e.g., `npm version`, `standard-version`).\n- Integrate the chosen tool into the release workflow (e.g., as a git hook or a release script).\n- Expose the version from `package.json` to the Next.js frontend (e.g., via build-time environment variables).\n- Add a small UI element to display the application version.",
        "testStrategy": "- Verify that the version bump script correctly increments the version in `package.json`.\n- Confirm that the new version is visible in the UI after a build.",
        "status": "deferred",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 64,
        "title": "Add Double-Click Shortcut to Edit List Title",
        "description": "Implement a shortcut to allow users to edit a list's title by double-clicking it. This improves user experience by providing a faster way to rename lists. The `Escape` key should cancel the edit.",
        "details": "In `components/list-column.tsx`, add an `onDoubleClick` handler to the list title element. This handler should set the component into its 'isEditing' state. The existing `handleCancelEdit` function, which is triggered by `Escape`, will handle cancellation.",
        "testStrategy": "1. Go to a board view.\n2. Double-click on a list's title.\n3. Verify that the title turns into an input field.\n4. Press `Escape` and verify the edit is cancelled.\n5. Double-click again, change the name, and press `Enter`. Verify the list title is updated.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 65,
        "title": "Fix Horizontal Overflow in Status View Modal",
        "description": "The modal that displays 'Done', 'Archived', or 'Deleted' cards has a horizontal overflow issue, forcing users to scroll right to see card content and actions. This task is to apply styling to constrain the width of the cards within the modal and ensure their content wraps correctly.",
        "details": "1. Identify the component responsible for rendering the status view modal (likely `view-status-dialog.tsx`).\n2. Analyze the CSS causing the card elements to overflow their container.\n3. Apply styles (e.g., `max-width`, `overflow-wrap: break-word`) to the card components within the modal to ensure they fit within the viewport without horizontal scrolling.",
        "testStrategy": "1. Open the 'Done Cards' view (or Archived/Deleted).\n2. Verify that the cards are contained within the modal without causing horizontal scrollbars.\n3. Ensure the card titles and content wrap correctly.\n4. Check that the 'View' and 'Restore' buttons are always visible.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 66,
        "title": "Implement Draggable Reordering for Lists",
        "description": "Allow users to reorder lists horizontally on the board page using drag-and-drop.",
        "status": "done",
        "dependencies": [73],
        "priority": "low",
        "details": "Using the existing `@atlaskit/pragmatic-drag-and-drop` library, implement the necessary draggable and drop-target adapters for the list columns. The implementation will follow the new architecture of using separate, dedicated elements for different drag-and-drop interactions within the ListColumn component. The `onDrop` handler will need to call a new `listService` function to persist the new order in Firestore. This work will begin after the card-dragging regression is fixed.",
        "testStrategy": "1. Test that lists can be dragged and reordered horizontally\n2. Verify that the new order is correctly persisted in Firestore\n3. Test edge cases like dragging the first list to the end and vice versa\n4. Ensure the UI updates immediately to reflect the new order before the backend sync completes",
        "subtasks": []
      },
      {
        "id": 67,
        "title": "Implement Draggable Reordering for Boards",
        "description": "Allow users to reorder their boards on the main dashboard using drag-and-drop. Note: Exploring alternative organization methods beyond simple drag-and-drop reordering.",
        "status": "deferred",
        "dependencies": [],
        "priority": "low",
        "details": "Using the existing `@atlaskit/pragmatic-drag-and-drop` library, implement the necessary draggable and drop-target adapters for the board cards on the dashboard. The `onDrop` handler will need to call a new `boardService` function to persist the new order in Firestore.\n\nAlternative organization methods to consider:\n1. Multi-board 'workspaces' - Allow users to group related boards into workspaces for better organization\n2. 'Starred boards' feature - Enable users to mark favorite boards for quick access\n3. Tagging/categorization system - Let users apply tags to boards for filtering and organization",
        "testStrategy": "If implemented, test both the drag-and-drop functionality and any alternative organization methods selected.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Research and evaluate alternative board organization methods (workspaces, starred boards, tagging)",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Create mockups for the preferred organization method(s)",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Gather user feedback on organization preferences before implementation",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 68,
        "title": "Create Reusable Skeleton Components",
        "description": "Create reusable skeleton placeholder components for card items and comment items. These will be used to prevent layout shift when loading asynchronous data in modals.",
        "details": "1. Create a new file `components/ui/skeleton.tsx` if it doesn't exist (based on shadcn/ui skeleton). \n2. Create a `CardSkeleton.tsx` component that visually mimics the layout and height of a card item shown in the `view-status-dialog.tsx`.\n3. Create a `CommentSkeleton.tsx` component that visually mimics the layout and height of a `comment-item.tsx`.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 69,
        "title": "Integrate Skeleton Loaders into Modals",
        "description": "Integrate the new skeleton components into the loading states of the `view-status-dialog` and `card-detail-dialog` to prevent layout shift.",
        "details": "1. In `view-status-dialog.tsx`, replace the `<LoadingSpinner />` with a list of `CardSkeleton` components when cards are being fetched.\n2. In `card-detail-dialog.tsx` (or its `comments-section.tsx` child), replace the loading state with a list of `CommentSkeleton` components when comments are being fetched.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 70,
        "title": "Implement Fixed-Top Positioning for Modals",
        "description": "Modify the styling of the main Dialog component to anchor it to the top of the viewport, preventing vertical movement when content changes.",
        "details": "1. Investigate the `shadcn/ui` Dialog component structure.\n2. Apply Tailwind CSS classes to the `DialogContent` component to override the default centering behavior.\n3. The goal is to align the modal to the top of the viewport (e.g., `top-0 translate-y-0` or similar) so that it only expands downwards.\n4. Test thoroughly to ensure this change doesn't negatively affect other dialog features or responsiveness.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 71,
        "title": "Fix Modal Width Blink on Scrollbar Appearance",
        "description": "When content in a modal is long enough to require a vertical scrollbar, the appearance of the scrollbar causes a horizontal 'blink' or layout shift. This task is to fix this by ensuring space is always reserved for the scrollbar.",
        "details": "In `card-detail-dialog.tsx` and `view-status-dialog.tsx`, find the elements styled with `overflow-y-auto` and change the class to `overflow-y-scroll`. This will prevent the content width from changing when the scrollbar appears.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 72,
        "title": "Improve Card Drag-and-Drop UX with Placeholder",
        "description": "Refactor the card drag-and-drop interaction to use a full-size placeholder (a 'ghost' card) instead of a simple drop indicator line. This will make the drop target clearer and prevent the list from resizing during reordering, creating a more stable and intuitive user experience.",
        "status": "done",
        "dependencies": [73],
        "priority": "high",
        "details": "1. Modify the drag-and-drop logic for cards, likely in `list-column.tsx` and `card-item.tsx`.\n2. Instead of rendering a `<DropIndicator />`, render a placeholder component (`CardSkeleton` or a new `CardPlaceholder`) that has the same dimensions as the card being dragged.\n3. The placeholder should appear in the list at the potential drop position.\n4. Ensure the list's size does not change while reordering a card within it.",
        "testStrategy": "",
        "subtasks": []
      },
      {
        "id": 73,
        "title": "fix(dnd): Restore broken card drag-and-drop functionality",
        "description": "A recent change to implement list dragging has introduced a regression that broke the existing card drag-and-drop feature. This task is to fix the regression by refactoring the `ListColumn` component to use separate elements for card drop targets and list drag sources, restoring the original card reordering functionality.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 74,
        "title": "Standardize Confirmation Dialog Across Card Components",
        "description": "Refactor card-related components to use a single, reusable confirmation dialog component instead of inconsistent approaches (custom AlertDialog vs window.confirm) to ensure UI consistency.",
        "details": "This task involves identifying and standardizing the confirmation dialog pattern used across card components:\n\n1. Review the existing confirmation dialog implementations:\n   - `board-card.tsx` uses a custom `AlertDialog` for confirming card deletion\n   - `card-detail-dialog.tsx` uses the browser's default `window.confirm`\n\n2. Create a reusable confirmation dialog component:\n   ```tsx\n   // components/ui/confirmation-dialog.tsx\n   import {\n     AlertDialog,\n     AlertDialogAction,\n     AlertDialogCancel,\n     AlertDialogContent,\n     AlertDialogDescription,\n     AlertDialogFooter,\n     AlertDialogHeader,\n     AlertDialogTitle,\n   } from \"@/components/ui/alert-dialog\";\n\n   interface ConfirmationDialogProps {\n     isOpen: boolean;\n     onClose: () => void;\n     onConfirm: () => void;\n     title: string;\n     description: string;\n     confirmLabel?: string;\n     cancelLabel?: string;\n   }\n\n   export function ConfirmationDialog({\n     isOpen,\n     onClose,\n     onConfirm,\n     title,\n     description,\n     confirmLabel = \"Confirm\",\n     cancelLabel = \"Cancel\",\n   }: ConfirmationDialogProps) {\n     return (\n       <AlertDialog open={isOpen} onOpenChange={onClose}>\n         <AlertDialogContent>\n           <AlertDialogHeader>\n             <AlertDialogTitle>{title}</AlertDialogTitle>\n             <AlertDialogDescription>{description}</AlertDialogDescription>\n           </AlertDialogHeader>\n           <AlertDialogFooter>\n             <AlertDialogCancel>{cancelLabel}</AlertDialogCancel>\n             <AlertDialogAction onClick={onConfirm}>{confirmLabel}</AlertDialogAction>\n           </AlertDialogFooter>\n         </AlertDialogContent>\n       </AlertDialog>\n     );\n   }\n   ```\n\n3. Refactor `board-card.tsx` to use the new component:\n   - Replace the existing AlertDialog implementation with the new ConfirmationDialog\n   - Ensure all functionality remains the same\n\n4. Refactor `card-detail-dialog.tsx` to use the new component:\n   - Replace all instances of `window.confirm` with the new ConfirmationDialog\n   - Add state management for controlling dialog visibility\n   - Update the component to handle the dialog open/close states\n\n5. Review other components in the application that might use confirmation dialogs:\n   - Identify any other components using either AlertDialog or window.confirm for similar purposes\n   - Refactor them to use the new ConfirmationDialog component\n\n6. Update any related tests to reflect the new implementation\n\n7. Document the new ConfirmationDialog component and its usage pattern for future development",
        "testStrategy": "1. Unit test the new ConfirmationDialog component:\n   - Test that it renders correctly with default props\n   - Test that it renders with custom labels\n   - Test that onConfirm and onClose callbacks are triggered correctly\n\n2. Integration test the refactored components:\n   - Verify that `board-card.tsx` still functions correctly with the new dialog\n   - Verify that `card-detail-dialog.tsx` shows the custom dialog instead of window.confirm\n   - Test that confirmation and cancellation work as expected in both components\n\n3. Visual regression testing:\n   - Compare screenshots before and after the refactoring to ensure UI consistency\n   - Verify that the dialog appears correctly on different screen sizes\n\n4. Accessibility testing:\n   - Test keyboard navigation within the dialog\n   - Verify that focus is properly trapped within the dialog when open\n   - Check that screen readers can properly announce the dialog content\n\n5. Cross-browser testing:\n   - Verify the dialog works consistently across Chrome, Firefox, Safari, and Edge\n\n6. Manual testing checklist:\n   - Confirm that deleting a card from board view works correctly\n   - Confirm that deleting a card from detail view works correctly\n   - Verify that other actions using the confirmation dialog work as expected\n   - Check that the dialog appears centered and properly styled in all contexts",
        "status": "done",
        "dependencies": [39, 40, 53],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 75,
        "title": "Fix Firebase Mock Configuration",
        "description": "Resolve CommonJS/ESM import conflicts in Firebase mock setup",
        "details": "Convert `lib/firebase.ts` to use dynamic ESM imports or move mock setup to test configuration. Update `vitest.setup.ts` and `lib/__mocks__/` accordingly.",
        "testStrategy": "Verify that tests execute without import errors",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 76,
        "title": "Add Missing Dependencies",
        "description": "Ensure all required packages are installed and configured",
        "details": "Audit and install missing dependencies like `tiny-invariant`. Update `package.json` and run dependency audits.",
        "testStrategy": "Verify that all tests can import dependencies without errors",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 77,
        "title": "Update Vitest Configuration",
        "description": "Fix Vitest mock hoisting and module resolution issues",
        "details": "Update `vitest.config.ts` to handle ESM properly and ensure correct mock configuration.",
        "testStrategy": "Run tests to ensure no configuration errors occur",
        "priority": "high",
        "dependencies": [75, 76],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 78,
        "title": "Restore Basic Test Execution",
        "description": "Ensure tests run without errors after initial fixes",
        "details": "Run a full test suite to verify that basic tests execute without errors.",
        "testStrategy": "Verify that at least some tests pass without errors",
        "priority": "high",
        "dependencies": [75, 76, 77],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 79,
        "title": "Create Test Wrapper Utilities",
        "description": "Develop comprehensive test wrappers for context providers",
        "details": "Create utilities in `vitest.setup.ts` and test utility files to provide BoardContext, ColumnContext, and authentication context.",
        "testStrategy": "Verify that context-dependent tests run without errors",
        "priority": "high",
        "dependencies": [78],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 80,
        "title": "Fix Context-Dependent Component Tests",
        "description": "Ensure all component tests have proper context setup",
        "details": "Update all component tests to use the new test wrapper utilities.",
        "testStrategy": "Verify that all context-dependent tests pass",
        "priority": "high",
        "dependencies": [79],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 81,
        "title": "Audit and Fix Existing Tests",
        "description": "Review each test file against current component implementations",
        "details": "Update tests in all 8 test files to match current application architecture.",
        "testStrategy": "Verify that previously passing tests are restored",
        "priority": "medium",
        "dependencies": [80],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 82,
        "title": "Standardize Test Patterns",
        "description": "Update test patterns for context providers and mocking",
        "details": "Create standardized test utilities in `lib/__tests__/test-utils.ts` for mocking and context providers.",
        "testStrategy": "Verify that tests use standardized patterns",
        "priority": "medium",
        "dependencies": [81],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 83,
        "title": "Add Missing Component Tests",
        "description": "Add comprehensive tests for new components",
        "details": "Focus on components like `create-board-dialog.tsx`, `create-list-dialog.tsx`, `reparent-card-dialog.tsx`, and `view-status-dialog.tsx`.",
        "testStrategy": "Verify that new tests pass and cover required functionality",
        "priority": "medium",
        "dependencies": [82],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 87,
        "title": "Update Testing Documentation",
        "description": "Align `testing.md` with current test infrastructure",
        "details": "Document new testing patterns, utilities, and workflows in `testing.md`.",
        "testStrategy": "Verify that documentation reflects current test setup",
        "priority": "low",
        "dependencies": [86],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 88,
        "title": "Enhance Mock Strategies",
        "description": "Improve Firebase and context mocking patterns",
        "details": "Refine mocking at the service layer and context providers for better test reliability.",
        "testStrategy": "Verify that improved mocks enhance test stability",
        "priority": "low",
        "dependencies": [87],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 89,
        "title": "Optimize Test Performance",
        "description": "Reduce test execution time",
        "details": "Analyze and optimize test execution to achieve faster test runs.",
        "testStrategy": "Verify that test execution time is under 30 seconds",
        "priority": "low",
        "dependencies": [88],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-02T16:14:13.391Z",
      "updated": "2025-10-23T00:08:54.708Z",
      "description": "Tasks for master context"
    }
  },
  "shared-boards": {
    "tasks": [
      {
        "id": 1,
        "title": "Design and implement database schema changes for multi-user support",
        "description": "Create the necessary database schema modifications to support multiple users collaborating on boards, including BoardMembership and Role models.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. Design a `BoardMembership` model that creates a many-to-many relationship between Users and Boards. Each membership should include: userId, boardId, role (enum: 'OWNER', 'EDITOR').\n2. The `Role` model should be implemented as an enum with initial values of 'OWNER' and 'EDITOR'.\n3. Modify the existing Board model to include a reference to the owner (the original creator).\n4. Implement appropriate database indexes for efficient queries.\n5. Create migration scripts for existing data to ensure backward compatibility.\n\nPseudo-code for BoardMembership model in Firebase:\n```\ninterface BoardMembership {\n  id: string;\n  userId: string;\n  boardId: string;\n  role: 'OWNER' | 'EDITOR';\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n}\n```",
        "testStrategy": "1. Unit test the new models to ensure they can be created/updated/deleted correctly.\n2. Test with mock data to ensure relationships are correctly established between users and boards.\n3. Verify that queries retrieving boards for a specific user return expected results.\n4. Test permission-based scenarios to ensure proper role enforcement.\n5. Validate migration of existing data.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Database Models and TypeScript Interfaces for Multi-User Support",
            "description": "Define the necessary TypeScript interfaces and implement the database models to support multi-user collaboration on boards, including BoardMembership model and Role enum.",
            "dependencies": [],
            "details": "1. Create TypeScript interface for 'Role' enum in lib/types.ts:\nexport type BoardRole = 'OWNER' | 'EDITOR';\n\n2. Create TypeScript interface for BoardMembership in lib/types.ts:\nexport interface BoardMembership {\n  id: string;\n  userId: string;\n  boardId: string;\n  role: BoardRole;\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n}\n\n3. Update the Board interface to include an ownerUserId field:\nexport interface Board {\n  // existing fields\n  ownerUserId: string; // Add this new field\n  // other existing fields\n}\n\n4. Create database indexes for efficient queries:\n   - Create an index on BoardMembership collection for (userId, boardId)\n   - Create an index on BoardMembership collection for (boardId, role)\n\n5. Implement any necessary helper functions for creating and managing these models in your database layer.",
            "status": "done",
            "testStrategy": "1. Write unit tests to verify the TypeScript interfaces provide proper type checking\n2. Test the creation, reading, updating, and deletion of BoardMembership objects in the database\n3. Verify that indexes are properly working by analyzing query performance\n4. Test that the Board model correctly handles the new ownerUserId field"
          },
          {
            "id": 2,
            "title": "Implement Database Migration Scripts and Update Security Rules",
            "description": "Create migration scripts to update existing data to the new schema and update Firestore security rules to enforce proper access control based on the new BoardMembership model.",
            "dependencies": [],
            "details": "1. Create a migration script to update existing Boards:\nasync function migrateExistingBoards() {\n  const boards = await db.collection('boards').get();\n  \n  const batch = db.batch();\n  for (const boardDoc of boards.docs) {\n    const board = boardDoc.data();\n    \n    // Assuming boards currently have a userId field indicating the creator\n    const ownerUserId = board.userId || board.createdBy;\n    \n    // Update board to include ownerUserId\n    batch.update(boardDoc.ref, { ownerUserId });\n    \n    // Create BoardMembership for the owner\n    const membershipRef = db.collection('board_memberships').doc();\n    batch.set(membershipRef, {\n      id: membershipRef.id,\n      boardId: boardDoc.id,\n      userId: ownerUserId,\n      role: 'OWNER',\n      createdAt: admin.firestore.FieldValue.serverTimestamp(),\n      updatedAt: admin.firestore.FieldValue.serverTimestamp()\n    });\n  }\n  \n  return batch.commit();\n}\n\n2. Update Firestore security rules (firestore.rules) to implement access control:\n// Define rules for the board_memberships collection\nmatch /board_memberships/{membershipId} {\n  allow read: if request.auth != null && \n    resource.data.userId == request.auth.uid;\n  \n  // Only allow creation if the user is adding themselves with proper validation\n  allow create: if request.auth != null && \n    request.resource.data.userId == request.auth.uid &&\n    exists(/databases/$(database)/documents/boards/$(request.resource.data.boardId));\n  \n  // Only allow the board owner to add/update other users' memberships\n  allow create, update, delete: if request.auth != null && \n    getBoardOwner(request.resource.data.boardId) == request.auth.uid;\n}\n\n// Update the rules for the boards collection\nmatch /boards/{boardId} {\n  // Helper function to get board owner\n  function getBoardOwner(boardId) {\n    return get(/databases/$(database)/documents/boards/$(boardId)).data.ownerUserId;\n  }\n  \n  // Helper function to check if user is a board member\n  function isBoardMember(boardId, userId) {\n    return exists(/databases/$(database)/documents/board_memberships/$(boardId + '_' + userId));\n  }\n  \n  // Allow read if user is a member\n  allow read: if request.auth != null && \n    (resource.data.ownerUserId == request.auth.uid || \n     isBoardMember(boardId, request.auth.uid));\n  \n  // Allow create for any authenticated user (they become the owner)\n  allow create: if request.auth != null && \n    request.resource.data.ownerUserId == request.auth.uid;\n  \n  // Allow update if user is a member (specific field restrictions can be added)\n  allow update: if request.auth != null && \n    (resource.data.ownerUserId == request.auth.uid || \n     isBoardMember(boardId, request.auth.uid));\n  \n  // Allow delete only for the board owner\n  allow delete: if request.auth != null && \n    resource.data.ownerUserId == request.auth.uid;\n}\n\n3. Create a script to apply these migrations and validate the results:\nasync function applyMigrations() {\n  try {\n    console.log('Starting database migration for multi-user support...');\n    await migrateExistingBoards();\n    console.log('Successfully migrated boards to new schema');\n    \n    // Validate migration\n    await validateMigration();\n    \n    console.log('Migration completed successfully');\n  } catch (error) {\n    console.error('Migration failed:', error);\n    // Add rollback mechanism if possible\n  }\n}",
            "status": "done",
            "testStrategy": "1. Create test boards and users to verify migration script works correctly\n2. Test rollback capability for the migration script\n3. Verify that Firestore security rules properly allow/deny operations based on user roles\n4. Test edge cases in security rules, such as:\n   - A user trying to access a board they don't have access to\n   - A non-owner trying to delete a board\n   - An editor trying to update board content\n5. Perform integration tests to ensure the entire authentication and authorization flow works"
          }
        ]
      },
      {
        "id": 2,
        "title": "Update backend API to support board sharing and permissions",
        "description": "Modify existing API endpoints to utilize the new database schema and enforce role-based access control.",
        "status": "done",
        "dependencies": [1],
        "priority": "high",
        "details": "1. Update all Board-related API endpoints to check for user permissions before allowing operations.\n2. Implement a middleware or service layer that verifies a user's role for a board.\n3. Modify board retrieval endpoints to include boards where the user is a member (not just owner).\n4. Enforce that only owners can delete boards or modify board settings.\n5. Ensure that editors can create/edit/move cards and lists.\n\nPseudo-code for permission middleware:\n```\nasync function verifyBoardAccess(req, res, next) {\n  const { boardId } = req.params;\n  const userId = req.user.id;\n  \n  const membership = await BoardMemberships.findOne({ boardId, userId });\n  \n  if (!membership) {\n    return res.status(403).json({ error: 'Access denied' });\n  }\n  \n  req.userRole = membership.role;\n  next();\n}\n```",
        "testStrategy": "1. Create unit tests for the middleware/service layer that handles permissions.\n2. For each API endpoint, test access with different user roles (owner, editor, non-member).\n3. Verify that operations are correctly allowed or denied based on role.\n4. Test error handling for unauthorized access attempts.\n5. Perform integration tests that simulate real user flows.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Board Access Middleware and Helper Functions",
            "description": "Create middleware and helper functions to verify user roles and board access permissions.",
            "dependencies": [],
            "details": "Create the verifyBoardAccess middleware as shown in the pseudo-code. Implement the getBoardRole helper function to retrieve a user's role for a specific board. Implement the isBoardMember helper function to check if a user has any access to a board. Add proper error handling in the middleware to return appropriate HTTP status codes. Ensure these functions use the board_memberships table from the new database schema.",
            "status": "done",
            "testStrategy": "Write unit tests for the middleware with various scenarios (owner access, editor access, no access). Test helper functions with different user and board combinations. Verify error handling works correctly for unauthorized access attempts."
          },
          {
            "id": 2,
            "title": "Update Board Retrieval Endpoints",
            "description": "Modify board retrieval endpoints to include boards where the user is a member, not just the owner.",
            "dependencies": ["2.1"],
            "details": "Update the getUserBoards function in firebase-service.ts to query both owned boards and shared boards via the board_memberships table. Modify the response structure to include the user's role for each board. Ensure the API maintains backward compatibility. Add pagination if needed for users with many boards. Consider adding filtering options (e.g., owned boards only, shared boards only).",
            "status": "done",
            "testStrategy": "Test the endpoint with users who have a mix of owned and shared boards. Verify all expected boards are returned with correct role information. Test with users who have no boards or only one type of board access. Benchmark performance for users with many boards."
          },
          {
            "id": 3,
            "title": "Enforce Role-Based Permissions in Board Operations",
            "description": "Update board operation endpoints to enforce role-based access control based on membership roles.",
            "dependencies": ["2.1"],
            "details": "Apply the verifyBoardAccess middleware to all board operation endpoints. Update the updateBoard function to check if user has appropriate permissions (owners can do everything, editors can update content). Modify the deleteBoard function to ensure only owners can delete boards. Update card and list operations to verify that editors have sufficient permissions. Review all board-related endpoints to ensure they properly implement the role-based restrictions.",
            "status": "done",
            "testStrategy": "Test board operations with different user roles to verify correct permissions. Verify owners can perform all operations. Test that editors can create/edit/move cards and lists but not delete boards or modify settings. Ensure non-members cannot access or modify any board data. Test edge cases like attempting to escalate privileges."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement backend invite functionality",
        "description": "Create API endpoints that allow board owners to invite other users by email or username, creating the appropriate BoardMembership records.",
        "status": "done",
        "dependencies": [1, 2],
        "priority": "medium",
        "details": "1. Create a new endpoint `POST /api/boards/{boardId}/invites` that accepts an email/username parameter.\n2. Verify that the requesting user is the board owner.\n3. Look up the target user by email/username.\n4. Create a new BoardMembership record with the target user ID and 'EDITOR' role.\n5. If the user doesn't exist, consider storing a pending invitation that can be claimed later (optional for MVP).\n\nPseudo-code for invite endpoint:\n```\nasync function inviteUser(req, res) {\n  const { boardId } = req.params;\n  const { email } = req.body;\n  const inviterId = req.user.id;\n  \n  // Verify inviter is board owner\n  const membership = await BoardMemberships.findOne({ boardId, userId: inviterId });\n  if (!membership || membership.role !== 'OWNER') {\n    return res.status(403).json({ error: 'Only board owners can invite users' });\n  }\n  \n  // Find user by email\n  const invitee = await Users.findOne({ email });\n  if (!invitee) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  \n  // Create new membership\n  await BoardMemberships.create({\n    boardId,\n    userId: invitee.id,\n    role: 'EDITOR'\n  });\n  \n  // Log activity\n  await Activities.create({\n    boardId,\n    userId: inviterId,\n    action: 'INVITE_USER',\n    details: { inviteeId: invitee.id }\n  });\n  \n  return res.status(200).json({ success: true });\n}\n```",
        "testStrategy": "1. Test successful invite scenarios with valid users.\n2. Test error cases (non-existent users, user already has access, etc.).\n3. Verify proper error messages are returned for each case.\n4. Test that only owners can invite users.\n5. Validate that activity is correctly logged for invites.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement user lookup helper service",
            "description": "Create a service function that can look up users by email or username for the invitation process",
            "dependencies": [],
            "details": "1. Create a new file `userService.js` (or extend existing one if available)\n2. Implement a `findUserByEmailOrUsername` function that accepts either email or username parameter\n3. The function should query the Users collection/table first by email, then by username if no match found\n4. Return the found user object or null if no user exists\n5. Include proper error handling for database issues\n6. Optimize with appropriate database indexes if needed",
            "status": "done",
            "testStrategy": "1. Write unit tests that verify users can be found by email\n2. Write unit tests that verify users can be found by username\n3. Test error cases like invalid inputs or database errors\n4. Test case sensitivity handling"
          },
          {
            "id": 2,
            "title": "Implement board ownership verification function",
            "description": "Create a function that verifies if a user is the owner of a board, to be used in the invite functionality",
            "dependencies": [],
            "details": "1. Create a `verifyBoardOwnership` function in the boardService\n2. Function should accept boardId and userId parameters\n3. Query the BoardMemberships collection to find the user's role for the specified board\n4. Return true if the user has 'OWNER' role, false otherwise\n5. Include proper error handling for cases where board doesn't exist or other DB errors\n6. Implement appropriate caching if performance is a concern",
            "status": "done",
            "testStrategy": "1. Test successful verification for board owners\n2. Test rejection for users with 'EDITOR' role\n3. Test rejection for users with no membership\n4. Test error handling for invalid board IDs"
          },
          {
            "id": 3,
            "title": "Implement board invite API endpoint",
            "description": "Create the REST API endpoint that handles user invitations to boards and creates the appropriate BoardMembership records",
            "dependencies": ["3.1", "3.2"],
            "details": "1. Create a new endpoint handler for `POST /api/boards/{boardId}/invites`\n2. Extract boardId from route parameters and email/username from request body\n3. Use the verifyBoardOwnership function to check if requester is board owner\n4. Return 403 error if requester is not board owner\n5. Use the user lookup service to find target user\n6. If target user isn't found, consider implementing a pending invitation system (optional for MVP) or return a 404 error\n7. Check if user already has membership to this board and return appropriate response\n8. Create new BoardMembership record with 'EDITOR' role\n9. Log the activity using the Activities service\n10. Return success response with the created membership",
            "status": "done",
            "testStrategy": "1. Test successful invitation flow with valid users\n2. Test error cases (non-existent users, users already with access)\n3. Test permission enforcement (non-owners cannot invite)\n4. Verify proper activity logging\n5. Test input validation and error handling"
          }
        ]
      },
      {
        "id": 4,
        "title": "Enhance Activity model for collaborative events",
        "description": "Extend the existing Activity model to track collaboration-related events such as invites, card creation, moves, and comments.",
        "status": "done",
        "dependencies": [1, 2],
        "priority": "medium",
        "details": "1. Review the existing Activity model and extend it to include user information and collaboration-specific action types.\n2. Define new action types: 'INVITE_USER', 'REMOVE_USER', etc.\n3. Ensure all relevant card and list operations update the activity log.\n4. Add appropriate indexes for querying recent activity on a board.\n5. Consider adding a 'visibility' field to potentially filter activities based on importance.\n\nPseudo-code for enhanced Activity model:\n```\ninterface Activity {\n  id: string;\n  boardId: string;\n  userId: string;  // Who performed the action\n  targetUserId?: string;  // For user-related actions like invites\n  action: 'CREATE_CARD' | 'MOVE_CARD' | 'COMMENT' | 'INVITE_USER' | 'REMOVE_USER';\n  details: any;  // JSON object with action-specific details\n  createdAt: Timestamp;\n}\n```\n\nImplementation for logging an activity:\n```\nasync function logActivity(boardId, userId, action, details) {\n  await Activities.create({\n    boardId,\n    userId,\n    action,\n    details,\n    createdAt: new Date()\n  });\n}\n```",
        "testStrategy": "1. Unit test new activity types to ensure they're correctly created.\n2. Verify that all relevant board operations properly log activities.\n3. Test retrieving activities for a specific board.\n4. Validate that activity entries contain all necessary information for UI display.\n5. Performance test to ensure activity logging doesn't impact general application performance.",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create front-end UI for sharing a board",
        "description": "Implement UI elements that allow a board owner to invite other users by entering their email or username.",
        "status": "done",
        "dependencies": [3],
        "priority": "high",
        "details": "1. Add a 'Share' button in the board header or menu that is only visible to board owners.\n2. Create a modal dialog with an input field for email/username and a submit button.\n3. Implement form validation for valid email format.\n4. Show appropriate success/error messages after invite attempts.\n5. Consider adding a simple animation or visual cue to indicate successful sharing.\n\nPseudo-code for Share component:\n```jsx\nfunction ShareBoardModal({ boardId, isOpen, onClose }) {\n  const [email, setEmail] = useState('');\n  const [status, setStatus] = useState('idle'); // idle, loading, success, error\n  const [errorMessage, setErrorMessage] = useState('');\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setStatus('loading');\n    \n    try {\n      const response = await api.inviteUserToBoard(boardId, email);\n      setStatus('success');\n      setTimeout(() => {\n        onClose();\n        setStatus('idle');\n        setEmail('');\n      }, 2000);\n    } catch (error) {\n      setStatus('error');\n      setErrorMessage(error.message || 'Failed to invite user');\n    }\n  };\n  \n  return (\n    <Modal isOpen={isOpen} onClose={onClose}>\n      <h2>Share Board</h2>\n      <form onSubmit={handleSubmit}>\n        <input \n          type=\"email\" \n          value={email} \n          onChange={(e) => setEmail(e.target.value)}\n          placeholder=\"Enter email address\"\n          required\n        />\n        <button type=\"submit\" disabled={status === 'loading'}>\n          {status === 'loading' ? 'Inviting...' : 'Invite'}\n        </button>\n      </form>\n      {status === 'success' && <p className=\"success\">Invitation sent!</p>}\n      {status === 'error' && <p className=\"error\">{errorMessage}</p>}\n    </Modal>\n  );\n}\n```",
        "testStrategy": "1. Create unit tests for the Share component UI.\n2. Test validation of email input.\n3. Verify UI behavior for all states: initial, loading, success, error.\n4. Test that the share button is only visible to owners.\n5. Conduct usability testing to ensure the sharing flow is intuitive.",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement the collaborator view of shared boards",
        "description": "Update the boards list and board view to show shared boards for collaborators and indicate they are shared.",
        "status": "done",
        "dependencies": [2, 5],
        "priority": "high",
        "details": "1. Modify the boards list API call to include boards where the user is a collaborator.\n2. Update the UI to display shared boards in the user's board list with a visual indicator that they are shared.\n3. Ensure the board view shows appropriate UI elements based on the user's role (e.g., hide delete/share options for editors).\n4. Add a visual indicator in the board header to show that a board is shared.\n\nPseudo-code for updated boards list component:\n```jsx\nfunction BoardsList() {\n  const [boards, setBoards] = useState([]);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    async function fetchBoards() {\n      try {\n        const response = await api.getBoards();\n        setBoards(response.data);\n      } catch (error) {\n        console.error('Failed to fetch boards:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    fetchBoards();\n  }, []);\n  \n  if (loading) return <LoadingSpinner />;\n  \n  return (\n    <div className=\"boards-list\">\n      {boards.map(board => (\n        <BoardCard \n          key={board.id} \n          board={board} \n          isShared={board.membership.role !== 'OWNER'}\n          role={board.membership.role}\n        />\n      ))}\n    </div>\n  );\n}\n\nfunction BoardCard({ board, isShared, role }) {\n  return (\n    <Link to={`/boards/${board.id}`} className=\"board-card\">\n      <h3>{board.title}</h3>\n      {isShared && (\n        <div className=\"shared-indicator\">\n          <ShareIcon /> Shared\n        </div>\n      )}\n    </Link>\n  );\n}\n```",
        "testStrategy": "1. Test that boards list correctly shows both owned and shared boards.\n2. Verify that shared boards are properly indicated in the UI.\n3. Test UI adaptations based on user role (elements visible/hidden appropriately).\n4. Test navigation to shared boards functions correctly.\n5. Validate user permissions are reflected in the UI (e.g., editor can't delete board).",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Develop activity log display in the UI",
        "description": "Create a UI component to display the activity log for a board, focusing on showing activities within card details.",
        "status": "done",
        "dependencies": [4, 6],
        "priority": "medium",
        "details": "1. Design and implement an activity log component that can be displayed in the card detail view.\n2. Create a service to fetch recent activities for a board or card.\n3. Format activity entries to be human-readable (e.g., \"Jane added a comment\" rather than \"USER_COMMENT\").\n4. Implement auto-refresh or polling to keep the activity log current.\n5. Consider adding filtering options for different activity types.\n\nPseudo-code for activity log component:\n```jsx\nfunction ActivityLog({ boardId, cardId }) {\n  const [activities, setActivities] = useState([]);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    async function fetchActivities() {\n      try {\n        const response = await api.getActivities(boardId, cardId);\n        setActivities(response.data);\n      } catch (error) {\n        console.error('Failed to fetch activities:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    fetchActivities();\n    \n    // Poll for updates every 30 seconds\n    const intervalId = setInterval(fetchActivities, 30000);\n    return () => clearInterval(intervalId);\n  }, [boardId, cardId]);\n  \n  function formatActivity(activity) {\n    const user = activity.user.name;\n    \n    switch (activity.action) {\n      case 'CREATE_CARD':\n        return `${user} created this card`;\n      case 'MOVE_CARD':\n        return `${user} moved this card from ${activity.details.fromList} to ${activity.details.toList}`;\n      case 'COMMENT':\n        return `${user} commented: \"${activity.details.comment}\"`;\n      case 'INVITE_USER':\n        return `${user} invited ${activity.details.inviteeName} to this board`;\n      default:\n        return `${user} performed an action`;\n    }\n  }\n  \n  if (loading) return <LoadingSpinner />;\n  \n  return (\n    <div className=\"activity-log\">\n      <h3>Activity</h3>\n      {activities.length === 0 ? (\n        <p>No activity yet</p>\n      ) : (\n        <ul>\n          {activities.map(activity => (\n            <li key={activity.id} className=\"activity-item\">\n              <div className=\"activity-content\">\n                <p>{formatActivity(activity)}</p>\n                <time>{new Date(activity.createdAt).toLocaleString()}</time>\n              </div>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test rendering of the activity log with sample data.\n2. Verify that activities are formatted correctly for different action types.\n3. Test polling/refresh functionality to ensure new activities appear.\n4. Validate date formatting and UI presentation in different browsers.\n5. Test with long activity lists to ensure performance and scrolling behavior.",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement permissions system on the frontend",
        "description": "Update the frontend to respect user roles and permissions, showing or hiding UI elements accordingly.",
        "status": "done",
        "dependencies": [2, 6],
        "priority": "medium",
        "details": "1. Create a permissions utility that can determine if a user can perform specific actions.\n2. Implement a UI context or hook to expose permission checks to components.\n3. Modify UI components to conditionally render based on permissions.\n4. Ensure that only owners can see board deletion and sharing options.\n5. Protect editor actions on the frontend to match backend permissions.\n\nPseudo-code for permissions utility and hook:\n```jsx\n// Permissions utility\nconst Permissions = {\n  canDeleteBoard: (userRole) => userRole === 'OWNER',\n  canInviteUsers: (userRole) => userRole === 'OWNER',\n  canEditCards: (userRole) => userRole === 'OWNER' || userRole === 'EDITOR',\n  canMoveCards: (userRole) => userRole === 'OWNER' || userRole === 'EDITOR',\n  canAddComments: (userRole) => userRole === 'OWNER' || userRole === 'EDITOR',\n};\n\n// Board context with permissions\nconst BoardContext = createContext(null);\n\nfunction BoardProvider({ children, boardId }) {\n  const [board, setBoard] = useState(null);\n  const [userRole, setUserRole] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    async function fetchBoardAndRole() {\n      try {\n        const response = await api.getBoard(boardId);\n        setBoard(response.data.board);\n        setUserRole(response.data.membership.role);\n      } catch (error) {\n        console.error('Failed to fetch board:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    fetchBoardAndRole();\n  }, [boardId]);\n  \n  const can = useCallback((action) => {\n    if (!userRole) return false;\n    return Permissions[action](userRole);\n  }, [userRole]);\n  \n  return (\n    <BoardContext.Provider value={{ board, loading, userRole, can }}>\n      {children}\n    </BoardContext.Provider>\n  );\n}\n\n// Hook to use permissions\nfunction useBoard() {\n  const context = useContext(BoardContext);\n  if (!context) {\n    throw new Error('useBoard must be used within a BoardProvider');\n  }\n  return context;\n}\n```\n\nUsage in a component:\n```jsx\nfunction BoardHeader() {\n  const { board, can } = useBoard();\n  const [shareModalOpen, setShareModalOpen] = useState(false);\n  \n  return (\n    <div className=\"board-header\">\n      <h1>{board.title}</h1>\n      <div className=\"board-actions\">\n        {can('canInviteUsers') && (\n          <button \n            onClick={() => setShareModalOpen(true)}\n            className=\"share-button\"\n          >\n            Share\n          </button>\n        )}\n        {can('canDeleteBoard') && (\n          <button className=\"delete-button\">\n            Delete Board\n          </button>\n        )}\n      </div>\n      \n      {shareModalOpen && (\n        <ShareBoardModal \n          boardId={board.id} \n          isOpen={shareModalOpen} \n          onClose={() => setShareModalOpen(false)} \n        />\n      )}\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Create unit tests for the permissions utility functions.\n2. Test the BoardContext with different user roles.\n3. Verify that UI components correctly show/hide elements based on permissions.\n4. Test boundary conditions (null user, loading state, etc.).\n5. Verify that frontend permissions align with backend permissions for consistency.",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Test and debug collaborative workflows",
        "description": "Perform comprehensive testing of the entire collaborative features set to ensure multiple users can effectively work together on shared boards.",
        "status": "done",
        "dependencies": [3, 5, 6, 7, 8],
        "priority": "high",
        "details": "1. Create test scenarios that cover the full range of collaborative interactions.\n2. Set up test environments with multiple user accounts for realistic testing.\n3. Test concurrent editing of the same board to identify potential race conditions.\n4. Verify that permissions are consistently enforced across all interactions.\n5. Test edge cases like inviting non-existent users, removing collaborators while they're active, etc.\n\nTest scenarios to implement:\n1. Board Owner invites a user who accepts and becomes an Editor\n2. Two users simultaneously edit different cards on the same board\n3. Two users simultaneously edit the same card (potential conflict)\n4. An Editor attempts to perform Owner-only actions (both UI and direct API calls)\n5. Owner removes an Editor while they are actively using the board\n6. Test activity log updates when multiple users are active\n\nPseudo-code for a test helper:\n```javascript\nasync function simulateMultiUserWorkflow() {\n  // Create test users\n  const owner = await TestHelper.createUser('owner@test.com');\n  const editor = await TestHelper.createUser('editor@test.com');\n  \n  // Owner creates a board\n  const board = await TestHelper.createBoard(owner, 'Test Collaborative Board');\n  \n  // Owner invites editor\n  await TestHelper.inviteUserToBoard(owner, board.id, editor.email);\n  \n  // Verify editor can see the board\n  const editorBoards = await TestHelper.getUserBoards(editor);\n  assert(editorBoards.some(b => b.id === board.id));\n  \n  // Editor creates a card\n  const list = board.lists[0];\n  const card = await TestHelper.createCard(editor, board.id, list.id, 'Test Card');\n  \n  // Owner modifies the card\n  await TestHelper.updateCard(owner, card.id, { title: 'Updated Title' });\n  \n  // Verify both users see the updated card\n  const ownerView = await TestHelper.getBoard(owner, board.id);\n  const editorView = await TestHelper.getBoard(editor, board.id);\n  \n  const ownerCard = ownerView.lists[0].cards.find(c => c.id === card.id);\n  const editorCard = editorView.lists[0].cards.find(c => c.id === card.id);\n  \n  assert(ownerCard.title === 'Updated Title');\n  assert(editorCard.title === 'Updated Title');\n  \n  // Verify activity log shows both users' actions\n  const activities = await TestHelper.getBoardActivities(board.id);\n  assert(activities.some(a => a.userId === editor.id && a.action === 'CREATE_CARD'));\n  assert(activities.some(a => a.userId === owner.id && a.action === 'UPDATE_CARD'));\n}\n```",
        "testStrategy": "1. Create automated test scripts for each collaborative workflow.\n2. Perform manual testing with real users in a staging environment.\n3. Use browser automation tools to simulate multiple users interacting concurrently.\n4. Test under various network conditions (e.g., slow connections, intermittent connectivity).\n5. Validate that error handling works properly in collaborative contexts.",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Documentation and deployment preparation",
        "description": "Create comprehensive documentation for the shared boards feature and prepare for deployment to production.",
        "status": "done",
        "dependencies": [9],
        "priority": "low",
        "details": "1. Document the database schema changes and new API endpoints.\n2. Create user-facing documentation on how to use shared boards.\n3. Update deployment scripts to handle the new models and relationships.\n4. Create a rollback plan in case issues arise in production.\n5. Document known limitations and future improvement areas.\n\nDocumentation to create:\n1. Technical documentation:\n   - Database schema diagram showing relationships\n   - API endpoint documentation with request/response examples\n   - Permissions matrix showing roles and allowed actions\n\n2. User documentation:\n   - How to share a board (owner perspective)\n   - How to access and work with shared boards (editor perspective)\n   - Activity log features and interpretation\n\n3. Deployment documentation:\n   - Required environment variables\n   - Migration steps for existing data\n   - Monitoring guidelines for the new features\n\nPseudo-code for deployment script update:\n```bash\n#!/bin/bash\n\n# Backup existing database\nfirebase firestore:backup --project=driftboard\n\n# Deploy Firebase Security Rules update\nfirebase deploy --only firestore:rules\n\n# Deploy updated Firebase Functions\nfirebase deploy --only functions\n\n# Deploy frontend with new features\nvercel deploy --prod\n\n# Run post-deployment verification\nnode scripts/verify-deployment.js\n\necho \"Deployment complete. Monitoring dashboard: https://vercel.com/driftboard/dashboard\"\n```",
        "testStrategy": "1. Review documentation for accuracy and completeness.\n2. Have someone unfamiliar with the feature attempt to use it based solely on the documentation.\n3. Test deployment process in a staging environment before production.\n4. Verify rollback procedure works as expected.\n5. Create a post-deployment monitoring plan to catch any issues quickly.",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-18T03:22:18.454Z",
      "updated": "2025-12-18T18:32:19.966Z",
      "description": "Tasks for shared-boards context"
    }
  },
  "infrastructure": {
    "tasks": [
      {
        "id": 84,
        "title": "Implement Pre-commit Hooks",
        "description": "Setup Husky for pre-commit hooks to run tests and linting",
        "details": "Install Husky and configure pre-commit hooks to prevent commits with failing tests.",
        "testStrategy": "Verify that hooks prevent commits with test failures",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "tag": "infrastructure",
        "metadata": {
          "moveHistory": [
            {
              "fromTag": "master",
              "toTag": "infrastructure",
              "timestamp": "2026-01-10T17:24:44.407Z"
            }
          ]
        }
      },
      {
        "id": 85,
        "title": "Setup CI/CD Integration",
        "description": "Configure GitHub Actions for automated test execution",
        "details": "Create a GitHub Actions workflow to run tests on PRs and merges. Include coverage reporting.",
        "testStrategy": "Verify that CI/CD pipeline runs tests successfully",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "tag": "infrastructure",
        "metadata": {
          "moveHistory": [
            {
              "fromTag": "master",
              "toTag": "infrastructure",
              "timestamp": "2026-01-10T17:24:44.407Z"
            }
          ]
        }
      },
      {
        "id": 86,
        "title": "Configure Quality Gates",
        "description": "Block merges on test failures and ensure coverage thresholds",
        "details": "Implement quality gates in the CI/CD pipeline to enforce test success and coverage targets.",
        "testStrategy": "Verify that merges are blocked on test failures",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "tag": "infrastructure",
        "metadata": {
          "moveHistory": [
            {
              "fromTag": "master",
              "toTag": "infrastructure",
              "timestamp": "2026-01-10T17:24:44.407Z"
            }
          ]
        }
      },
      {
        "id": 87,
        "title": "Research Firebase Infrastructure as Code and Deployment Pipeline Integration",
        "description": "Investigate and document best practices for implementing Infrastructure as Code for Firebase resources and how to integrate these practices into our existing deployment pipeline.",
        "details": "1. Research IAC tools compatible with Firebase (Firebase CLI, Terraform, Pulumi, etc.)\n2. Compare the features, benefits, and limitations of each tool\n3. Document how to define Firebase resources (Firestore, Functions, Hosting, etc.) as code\n4. Investigate how to integrate the chosen IAC approach with our existing GitHub Actions CI/CD pipeline\n5. Research versioning strategies for Firebase infrastructure\n6. Explore testing strategies for Firebase infrastructure\n7. Document the recommended approach with example configurations\n8. Consider security best practices for Firebase IAC\n9. Analyze cost implications of different approaches\n10. Evaluate implementation complexity and required team knowledge",
        "testStrategy": "1. Create a proof-of-concept implementation using the recommended IAC tool\n2. Verify that Firebase resources can be provisioned successfully using the IAC configuration\n3. Test the integration with the existing CI/CD pipeline\n4. Validate that the approach supports different environments (dev, staging, production)\n5. Ensure the solution allows for easy rollbacks if necessary\n6. Document any limitations or potential issues discovered during testing",
        "status": "pending",
        "dependencies": [85],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-01-10T17:08:21.441Z",
      "updated": "2026-01-10T20:11:47.187Z",
      "description": "Tag created on 1/10/2026"
    }
  },
  "separation": {
    "tasks": [
      {
        "id": 1,
        "title": "Research and Plan Architecture for Driftboard Front-end/Back-end Separation",
        "description": "Investigate and document a strategy for breaking Driftboard into separate front-end and back-end components, with consideration for microservices or other appropriate architectural patterns that would support multiple front-end interfaces.",
        "details": "1. Analyze the current Driftboard architecture to identify clear separation points between data/business logic and presentation layers.\n\n2. Research and evaluate architectural patterns suitable for this separation:\n   - Traditional client-server architecture\n   - Microservices architecture\n   - API Gateway pattern\n   - Backend for Frontend (BFF) pattern\n   - Event-driven architecture\n\n3. Design a high-level architecture diagram showing:\n   - Core back-end services/components\n   - API layers and interface contracts\n   - Front-end application structure for different clients (web boards, web notes, CLI, etc.)\n   - Authentication and authorization flow across components\n   - Data persistence strategy\n\n4. Consider technical implications including:\n   - State management across distributed components\n   - Deployment strategy (containerization, orchestration)\n   - Development workflow changes needed\n   - Performance considerations with distributed architecture\n   - Cross-cutting concerns (logging, monitoring, error handling)\n\n5. Document migration strategy from current architecture to proposed architecture, including phasing recommendations and potential risks.\n\n6. Create a proof-of-concept design for one specific feature to demonstrate the architecture's viability.",
        "testStrategy": "1. Peer review of architectural documentation with stakeholders to validate requirements are met\n\n2. Create evaluation matrix comparing different architectural approaches against key criteria:\n   - Scalability\n   - Maintainability\n   - Development velocity\n   - Technology alignment\n   - Implementation complexity\n\n3. Prototype a minimal implementation of the proposed architecture using one representative feature (like board creation) that exercises both front-end and back-end components\n\n4. Conduct load testing on the prototype to validate performance assumptions\n\n5. Document potential failure modes and mitigation strategies for the proposed architecture\n\n6. Present findings to the development team for feedback and validation of technical approach",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-01-10T20:18:33.361Z",
      "updated": "2026-01-10T20:21:06.517Z",
      "description": "Tag created on 1/10/2026"
    }
  },
  "ui": {
    "tasks": [
      {
        "id": 1,
        "title": "Enhance Shared Boards with Visual Indicators and Access Lists",
        "description": "Implement visual indicators to show when a board is shared and display a list of users who have access to it, ensuring the access list is only visible to authorized users.",
        "details": "This task involves adding functionality to clearly identify shared boards and show who has access to them, while maintaining appropriate security controls. Implementation should include:\n\n1. Visual Indicator Component:\n   - Create a distinct visual element (icon/badge) that appears on shared boards\n   - Position the indicator consistently in the board UI (header or board card)\n   - Ensure indicator is visible to all users with access to the board\n\n2. Access List Component:\n   - Develop a UI component to display users who have access to the board\n   - Include user avatars, names, and potentially their access level\n   - Make the list accessible via an intuitive UI action (click/hover on share indicator)\n\n3. Visibility Logic:\n   - Implement conditional rendering for the access list based on user authorization\n   - Only show the access list to users who have been granted access to the board\n   - Add server-side validation to ensure access list data is only provided to authorized users\n\n4. Authentication Integration:\n   - Connect to existing authentication system to obtain current user information\n   - Use authentication status to determine whether a user should see specific board information\n\n5. Future Compatibility:\n   - Design the data structure to accommodate future 'public' boards without major refactoring\n   - Prepare for future role-based relationships (viewer/editor/owner) in the data model\n   - Document assumptions and design decisions for future developers\n\n6. Security Measures:\n   - Implement proper authorization checks on both client and server\n   - Ensure API endpoints that retrieve board sharing information verify user permissions\n   - Add appropriate error handling for unauthorized access attempts",
        "testStrategy": "To verify the correct implementation of the shared board enhancements:\n\n1. Unit Tests:\n   - Test the shared board indicator component renders correctly based on board sharing status\n   - Test access list component renders the correct users with proper formatting\n   - Test visibility logic correctly determines when to show/hide the access list\n\n2. Integration Tests:\n   - Verify the board sharing indicator appears only on boards that are actually shared\n   - Confirm the access list appears only when an authorized user interacts with the sharing indicator\n   - Test that users who don't have access to a board cannot see the access list\n\n3. Security Tests:\n   - Attempt to access the list of users for a board via API when not authorized\n   - Verify server properly rejects unauthorized requests for board access information\n   - Test that the front-end properly handles and displays authorization errors\n\n4. User Flow Tests:\n   - Create test scenarios with multiple users and shared boards\n   - Verify correct behavior when a user's access is revoked while they're viewing the board\n   - Test user experience when sharing/unsharing boards\n\n5. Cross-browser Testing:\n   - Verify the sharing indicator and access list display correctly across different browsers\n   - Test responsive behavior on different screen sizes\n\n6. Accessibility Testing:\n   - Verify new UI elements are keyboard accessible\n   - Test with screen readers to ensure proper announcements\n   - Check color contrast for visual indicators\n\nDocument test results with screenshots and clear pass/fail criteria.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create backend API endpoints for board sharing data",
            "description": "Implement RESTful API endpoints to retrieve board sharing status and access list data with proper authorization checks.",
            "dependencies": [],
            "details": "Create GET /api/boards/{id}/sharing endpoint that returns sharing status and access list. Implement server-side authorization to ensure only authorized users can access this data. Include user IDs, names, avatars, and access levels in the response. Add proper error handling for unauthorized requests returning 403 status codes.",
            "status": "done",
            "testStrategy": "Test API endpoint with authenticated and unauthenticated users. Verify correct data is returned for authorized users and 403 errors for unauthorized users. Test with various board sharing configurations."
          },
          {
            "id": 2,
            "title": "Build shared board visual indicator React component",
            "description": "Develop a reusable React component that displays a visual indicator when a board is shared.",
            "dependencies": [1],
            "details": "Create a ShareIndicator component that accepts board data as props. Use a users icon with a badge that appears when board.isShared is true. Position it consistently in the board header or card. Style with CSS for clear visibility. Make it clickable to open the access list. Ensure component is responsive and accessible with proper ARIA labels.",
            "status": "done",
            "testStrategy": "Unit test component rendering based on isShared prop. Test click handler functionality. Verify icon displays correctly and has proper accessibility attributes. Test component in both board header and board card contexts."
          },
          {
            "id": 3,
            "title": "Develop access list display component",
            "description": "Create a React component to show the list of users with access to a shared board.",
            "dependencies": [1],
            "details": "Build AccessList component that displays user avatars, names, and access levels in a modal or dropdown overlay. Fetch data from /api/boards/{id}/sharing endpoint using React Query or similar. Include loading states, error handling, and empty state UI. Style with proper spacing, typography, and user-friendly layout. Implement close/on-click outside behavior.",
            "status": "done",
            "testStrategy": "Test component with mock user data including various access levels. Verify avatar rendering, name display, and access level badges. Test loading and error states. Ensure modal/dropdown opens and closes correctly."
          },
          {
            "id": 4,
            "title": "Implement authorization logic and security measures",
            "description": "Add client-side and server-side authorization checks to control access list visibility based on user permissions.",
            "dependencies": [1, 2, 3],
            "details": "Implement useAuthorization hook to check user permissions against board access control list. Add conditional rendering logic to only show access list to authorized users. Enhance API endpoint with robust permission validation and audit logging. Add error boundaries for unauthorized access attempts. Implement rate limiting on sharing endpoints.",
            "status": "done",
            "testStrategy": "Integration tests for full authorization flow. Test that unauthorized users cannot see access list UI or API data. Verify API rejects unauthorized requests with proper error messages. Test security audit logs are created."
          },
          {
            "id": 5,
            "title": "Integrate authentication system and add future compatibility",
            "description": "Connect components to existing authentication system and prepare data structures for future enhancements.",
            "dependencies": [1, 2, 3, 4],
            "details": "Integrate with existing auth provider to get current user info and pass to components. Update TypeScript interfaces to support future 'public' boards and role-based access levels (viewer/editor/owner). Add feature flags for gradual rollout. Create comprehensive documentation of design decisions, security model, and API contracts. Add JSDoc comments to all public functions.",
            "status": "done",
            "testStrategy": "End-to-end tests with real authentication flow. Test future data structure compatibility by mocking upcoming features. Verify documentation accuracy and completeness. Test feature flag functionality."
          }
        ]
      },
      {
        "id": 2,
        "title": "Fix Card View Mobile Responsiveness and Layout Issues",
        "description": "Resolve mobile styling problems in card view including overflow from long URLs, cards exceeding screen width requiring horizontal scrolling, and mispositioned UI elements.",
        "details": "## Problem Analysis & Reproduction\nFirst, reproduce the super-long card issue caused by URLs. Create test cards with:\n- Unbroken URLs longer than 50 characters\n- Mixed content with long words\n- Various content types (links, code blocks, long strings)\n\n## Mobile-First CSS Implementation\n\n### 1. Card Container Constraints\n```css\n.card-container {\n  max-width: 100vw;\n  width: 100%;\n  overflow-x: hidden;\n  padding: 0 12px; /* Add safe margins */\n  box-sizing: border-box;\n}\n\n@media (max-width: 768px) {\n  .card {\n    width: 100% !important;\n    min-width: auto !important;\n    margin: 8px 0;\n  }\n}\n```\n\n### 2. URL/Text Wrapping Fixes\n```css\n.card-content {\n  word-wrap: break-word;\n  overflow-wrap: break-word;\n  word-break: break-word;\n  min-width: 0; /* Critical for flexbox children */\n}\n\n/* Specific handling for anchor tags */\n.card-content a {\n  display: inline-block;\n  max-width: 100%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: normal;\n}\n```\n\n### 3. UI Element Positioning Audit\nReview and fix these specific mobile issues:\n- Card action buttons (edit, delete, share) - ensure they stack vertically or use proper touch targets (44x44px minimum)\n- Card metadata (dates, author) - reposition from absolute/fixed to flow layout\n- Checklist progress bars - constrain width to card boundaries\n- Labels/tags - implement wrapping container with flex-wrap\n\n### 4. Viewport & Meta Tag Verification\nEnsure HTML includes:\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=5.0\">\n```\n\n### 5. User Feedback Mechanism\nBefore finalizing implementation:\n- Create 2-3 design mockups showing different approaches\n- Deploy to staging environment with interactive examples\n- Collect feedback on: card padding, button placement, text size, scrolling behavior\n- Document specific device/browser combinations that exhibit issues\n\n## Implementation Steps\n1. Audit current card CSS for fixed widths and overflow properties\n2. Create a test suite with problematic content examples\n3. Implement responsive breakpoints (320px, 375px, 414px, 768px)\n4. Fix UI element positioning using flexbox/grid instead of absolute positioning\n5. Test on physical devices (iPhone SE, iPhone 13, Pixel 6, Samsung Galaxy)\n6. Gather user feedback via staging preview\n7. Iterate based on feedback before production deployment",
        "testStrategy": "## Testing Approach\n\n### 1. Content Overflow Testing\n- Create cards with URLs of varying lengths: 50, 100, 200+ characters\n- Test with unbroken text strings and mixed alphanumeric content\n- Verify no horizontal scrolling on viewport widths from 320px to 768px\n- Confirm text wraps cleanly without breaking word readability unnecessarily\n\n### 2. Device-Specific Testing Matrix\nTest on these physical devices or browser emulators:\n- **iOS**: iPhone SE (375x667), iPhone 13 (390x844), iPad Mini (768x1024)\n- **Android**: Pixel 6 (412x915), Samsung Galaxy S21 (360x780)\n- Verify in both portrait and landscape orientations\n\n### 3. UI Element Positioning Validation\n- Measure all interactive elements meet 44x44px minimum touch target size\n- Confirm action buttons are reachable with thumb navigation\n- Verify metadata elements don't overlap or obscure content\n- Test with system font sizes set to maximum accessibility settings\n\n### 4. Cross-Browser Compatibility\n- Safari iOS (14+)\n- Chrome Android (90+)\n- Firefox Mobile\n- Samsung Internet\n\n### 5. Performance Testing\n- Measure rendering time for boards with 50+ cards on mobile network\n- Ensure CSS changes don't negatively impact desktop performance\n- Check for layout thrashing or excessive repaints using Chrome DevTools\n\n### 6. User Acceptance Testing\n- Deploy to staging with at least 5 different board configurations\n- Provide feedback form specifically asking about: card readability, button accessibility, scrolling experience\n- Require sign-off from 3+ team members on different devices before production release",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": ": ",
        "description": ": ",
        "details": ": ",
        "testStrategy": ": ",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-01-10T20:43:26.587Z",
      "updated": "2026-01-12T04:48:54.748Z",
      "description": "Tag created on 1/10/2026"
    }
  },
  "security": {
    "tasks": [
      {
        "id": 1,
        "title": "Secure Client-Side Board Sharing and Firestore Rules",
        "description": "Restrict Firestore access to board memberships and user data to authorized users only, addressing vulnerabilities exposed by client-side refactor.",
        "details": "The recent refactor moved board sharing logic to the client, relying on permissive `firestore.rules` (`allow read: if isAuthenticated()`). This allows any user to scrape membership data.\n\nAction Items:\n1. Modify `firestore.rules` to restrict `board_memberships` read access. Users should only read memberships for boards they own or are members of.\n2. Evaluate if a return to Server Actions/API is necessary for secure, efficient querying if rules become too complex.\n3. Ensure `users` collection access is scoped appropriately (e.g., only visible to shared board members).\n4. Verify no sensitive data (emails) is exposed to unauthorized users.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-01-11T17:46:59.004Z",
      "updated": "2026-01-11T17:47:03.924Z",
      "description": "Tasks related to security improvements and hardening."
    }
  }
}
