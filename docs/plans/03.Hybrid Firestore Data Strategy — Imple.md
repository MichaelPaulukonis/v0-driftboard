# Hybrid Firestore Data Strategy — Implementation Checklist

### 1. Data Model Changes

*   Add `status` field to all entities: `active | done | deleted | archived | inactive`.
    *   **Note**: The `status` enum is preferred over a simple `isDeleted` boolean to accommodate future states like 'archived' or 'done' without further schema changes.
*   Replace legacy `isDeleted` boolean → map to `status: 'deleted'`.
*   Add metadata fields to current docs:
    *   `createdAt` (serverTimestamp), `createdBy` (uid)
    *   `updatedAt` (serverTimestamp), `updatedBy` (uid)
*   Use timestamps (not integers) for version ordering.
*   Add `position` float to list-ordered entities (cards, tasks).

---

### 2. Collections & Subcollections

*   `*_current/{entityId}` → one document per logical entity (fast reads).
*   `*_current/{entityId}/history/{historyId}` → immutable snapshots of every change.
*   Example: `cards_current/{cardId}/history/{autoId}`.

---

### 3. History Document Shape

*   Fields:
    *   `changeType`: `create|update|delete|done|restore`
    *   `createdAt` (serverTimestamp), `createdBy` (uid)
    *   `snapshot`: full copy of the entity state at that time
    *   `summary` (optional human-readable description)

---

### 4. Write Patterns

*   **Create**: write current doc + initial history (`changeType: create`) in one batch.
*   **Update**: batch/transaction → add history entry (`changeType: update`, full snapshot), then update current doc (`updatedAt/By`).
*   **Soft delete**: history entry (`changeType: delete`), set `status: deleted`.
*   **Mark done**: history entry (`changeType: done`), set `status: done`.
*   **Restore**: history entry (`changeType: restore`), set `status: active`.

---

### 5. Query Patterns

*   Active items: `where('status','==','active')` on `*_current`.
    *   **Note**: ALL data-fetching functions in the application must be updated to include a `where('status', '==', 'active')` clause to hide soft-deleted items from the UI by default.
*   Done/archived: include those statuses in query.
*   History: order by `createdAt desc` in subcollection.
*   Recent activity: order `*_current` by `updatedAt desc`.

---

### 6. Firestore Indexes

*   Composite:
    *   `listId + status + position` (for ordered list queries).
    *   `boardId + updatedAt` (for activity feeds).
*   Rely on Firestore prompts for additional needed indexes.

---

### 7. Security Rules

*   Require `request.auth.uid != null`.
*   Validate `status` is one of allowed enum values.
*   Require server timestamps for `createdAt`/`updatedAt`.
*   Allow client to write both current + history in batch.
*   (Optional future hardening: restrict history writes to server functions.)

---

### 8. Migration Steps

**Note**: This migration is critical to resolve the current data integrity issue of hard deletes orphaning child documents (e.g., lists and cards remaining after a board is deleted).

**[DONE] 0. Pre-Migration: Unify on Soft Deletes**
*   The codebase has been updated to use soft deletes (`status: 'deleted'`) for all models.
*   A migration script was used to backfill the `status` field on existing documents.
*   This phase is complete. The next steps focus on the full migration to the `_current` and `history` structure.

**1. Backup Firestore.**
2.  For each doc in legacy collections:
    *   Copy to new `*_current/{id}`.
    *   Map `isDeleted: true → status: deleted`, else `status: active`.
    *   Set `createdAt/By` from existing fields; fallback to now.
    *   Set `updatedAt/By = createdAt/By` initially.
    *   Add `position` if missing.
3.  Seed initial history doc (`changeType: create`, snapshot = original state).
4.  Switch UI reads/writes to new collections.
5.  Remove/rename legacy collections only after validation.

---

### 9. UI Updates

*   Default: show only `status == active`.
*   Add toggles for done/archived/deleted views.
*   Card/task history view → fetch subcollection.
*   “Undo/Restore” → update status back to active, add history entry.
*   Use `updatedAt/By` for “last edited” labels and activity feeds.

---

### 10. Cost & Performance

*   Expect 2 writes per change (current + history).
*   Reads stay cheap (from `*_current`).
*   Storage grows with history snapshots — keep snapshots minimal.
*   Timestamps keep ordering trivial.

---

### 11. Concurrency

*   For critical updates (e.g., reordering): use Firestore transactions.
*   For simple edits: batched writes with optimistic UI.
*   Optionally detect conflicts by comparing `updatedAt` with UI-cached value.

---

### 12. Retention & GC

*   Default: keep all history indefinitely.
*   Optional later: scheduled cleanup/archiving of old history (Cloud Functions).
*   Permanent delete (GDPR) = remove both current + history manually.

---

✅ **End result**: Fast reads from `*_current`, full immutable audit trail in per-entity history, consistent non-destructive lifecycle (`status` enum), lightweight security, easy migration, and clean UI hooks.

