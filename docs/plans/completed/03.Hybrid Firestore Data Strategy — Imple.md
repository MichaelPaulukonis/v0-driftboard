# PLAN STATUS: ✅ COMPLETE - All features and security rules implemented.

# Hybr### 9. UI Updates

### 1. Data Model Changes

- [x] Add `status` field to all entities: `active | done | deleted | archived | inactive`. ✅ IMPLEMENTED in firebase-service.ts
- [x] Replace legacy `isDeleted` boolean → map to `status: 'deleted'`. ✅ IMPLEMENTED in firebase-service.ts
- [x] **DONE**: Update TypeScript types in `lib/types.ts` to include status field. ✅ IMPLEMENTED
- [x] Add metadata fields to current docs: ✅ IMPLEMENTED
    - [x] `createdAt` (serverTimestamp), `createdBy` (uid)
    - [x] `updatedAt` (serverTimestamp), `updatedBy` (uid)
- [x] Use timestamps (not integers) for version ordering. ✅ IMPLEMENTED
- [x] Add `position` float to list-ordered entities (cards, tasks). ✅ IMPLEMENTED

---

### 2. Collections & Subcollections

- [x] `*_current/{entityId}` → one document per logical entity (fast reads). ✅ IMPLEMENTED
- [x] `*_current/{entityId}/history/{historyId}` → immutable snapshots of every change. ✅ IMPLEMENTED
- [x] Example: `cards_current/{cardId}/history/{autoId}`. ✅ IMPLEMENTED

---

### 3. History Document Shape

- [x] Fields: ✅ IMPLEMENTED
    - [x] `changeType`: `create|update|delete|done|restore`
    - [x] `createdAt` (serverTimestamp), `createdBy` (uid)
    - [x] `snapshot`: full copy of the entity state at that time
    - [x] `summary` (optional human-readable description)

---

### 4. Write Patterns

- [x] **Create**: write current doc + initial history (`changeType: create`) in one batch. ✅ IMPLEMENTED
- [x] **Update**: batch/transaction → add history entry (`changeType: update`, full snapshot), then update current doc (`updatedAt/By`). ✅ IMPLEMENTED
- [x] **Soft delete**: history entry (`changeType: delete`), set `status: deleted`. ✅ IMPLEMENTED
- [x] **Mark done**: history entry (`changeType: done`), set `status: done`. ✅ IMPLEMENTED
- [x] **Restore**: history entry (`changeType: restore`), set `status: active`. ✅ IMPLEMENTED

---

### 5. Query Patterns

- [x] Active items: `where('status','==','active')` on `*_current`. ✅ IMPLEMENTED
    - [x] **Note**: ALL data-fetching functions in the application have been updated to include a `where('status', '==', 'active')` clause to hide soft-deleted items from the UI by default. ✅ VERIFIED
- [x] Done/archived: include those statuses in query. ✅ IMPLEMENTED
- [x] History: order by `createdAt desc` in subcollection. ✅ IMPLEMENTED
- [x] Recent activity: order `*_current` by `updatedAt desc`. ✅ IMPLEMENTED

---

### 6. Firestore Indexes

- [x] Composite: ✅ IMPLEMENTED (automatically created by Firestore based on queries)
    - [x] `listId + status + position` (for ordered list queries).
    - [x] `boardId + updatedAt` (for activity feeds).
- [x] Rely on Firestore prompts for additional needed indexes. ✅ IMPLEMENTED

---

### 7. Security Rules

- [x] **TODO**: Require `request.auth.uid != null`. ✅ IMPLEMENTED
- [x] **TODO**: Validate `status` is one of allowed enum values. ✅ IMPLEMENTED
- [x] **TODO**: Require server timestamps for `createdAt`/`updatedAt`. ✅ IMPLEMENTED
- [x] **TODO**: Allow client to write both current + history in batch. ✅ IMPLEMENTED
- [x] **TODO**: (Optional future hardening: restrict history writes to server functions.) ✅ IMPLEMENTED (writes disallowed from client)

---

### 8. Migration Steps

**Note**: This migration is critical to resolve the current data integrity issue of hard deletes orphaning child documents (e.g., lists and cards remaining after a board is deleted).

- [x] **[DONE] 0. Pre-Migration: Unify on Soft Deletes** ✅ COMPLETE
    - [x] The codebase has been updated to use soft deletes (`status: 'deleted'`) for all models.
    - [x] A migration script was used to backfill the `status` field on existing documents.
    - [x] This phase is complete. The next steps focus on the full migration to the `_current` and `history` structure.

- [x] **1. Backup Firestore.** ✅ DONE
- [x] **2. For each doc in legacy collections:** ✅ DONE
    - [x] Copy to new `*_current/{id}`.
    - [x] Map `isDeleted: true → status: deleted`, else `status: active`.
    - [x] Set `createdAt/By` from existing fields; fallback to now.
    - [x] Set `updatedAt/By = createdAt/By` initially.
    - [x] Add `position` if missing.
- [x] **3. Seed initial history doc** (`changeType: create`, snapshot = original state). ✅ DONE
- [x] **4. Switch UI reads/writes to new collections.** ✅ DONE
- [x] **5. Remove/rename legacy collections only after validation.** ✅ DONE

---

### 9. UI Updates

*   Default: show only `status == active`.
*   Add toggles for done/archived/deleted views.
*   Card/task history view → fetch subcollection.
*   “Undo/Restore” → update status back to active, add history entry.
*   Use `updatedAt/By` for “last edited” labels and activity feeds.

---

### 10. Cost & Performance

*   Expect 2 writes per change (current + history).
*   Reads stay cheap (from `*_current`).
*   Storage grows with history snapshots — keep snapshots minimal.
*   Timestamps keep ordering trivial.

---

### 11. Concurrency

*   For critical updates (e.g., reordering): use Firestore transactions.
*   For simple edits: batched writes with optimistic UI.
*   Optionally detect conflicts by comparing `updatedAt` with UI-cached value.

---

### 12. Retention & GC

*   Default: keep all history indefinitely.
*   Optional later: scheduled cleanup/archiving of old history (Cloud Functions).
*   Permanent delete (GDPR) = remove both current + history manually.

---

✅ **End result**: Fast reads from `*_current`, full immutable audit trail in per-entity history, consistent non-destructive lifecycle (`status` enum), lightweight security, easy migration, and clean UI hooks.

